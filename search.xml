<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS3第一天(新特性与选择器)</title>
    <url>/2021/06/02/CSS3%E7%AC%AC%E4%B8%80%E5%A4%A9-%E6%96%B0%E7%89%B9%E6%80%A7%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="CSS3新特性学习"><a href="#CSS3新特性学习" class="headerlink" title="CSS3新特性学习"></a>CSS3新特性学习</h2><p>-css3是css2.1的一个升级版，它是对CSS的一个扩展。</p>
<span id="more"></span>

<h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3><p>-选择器</p>
<p>-阴影</p>
<p>-形状转换（2D&lt;-&gt;3D）</p>
<p>-变形</p>
<p>-动画</p>
<p>-边框</p>
<p>-多重背景</p>
<p>-反射</p>
<p>-文字</p>
<p>-颜色（rgba/hsl/hsla）</p>
<p>-滤镜（fitter）</p>
<p>-弹性布局</p>
<p>-多列布局</p>
<p>-盒模型</p>
<p>-Web字体</p>
<p>-媒体查询</p>
<h3 id="厂商前缀"><a href="#厂商前缀" class="headerlink" title="厂商前缀"></a>厂商前缀</h3><p>-CSS3不是浏览器或同一浏览器的不同版本都支持，所以需要兼容，通常做法是加厂商前缀</p>
<p>  -1.主流浏览器内核</p>
<p>a）Trident：IE内核</p>
<p>b）WebKit：Chome和Safair内核</p>
<p>c）Gecko：FireFox内核</p>
<p>d）Blink（Webkit一个分支）：Chrome和Opera内核</p>
<p>  Tips：目前国内的浏览器大多都是双核的（IE内核+Chrome内核）</p>
<p>-2.厂商前缀</p>
<p>  IE：-ms-</p>
<p>  Chrome&amp;Safari: -webKit-</p>
<p>  FireFox: -moz-</p>
<p>  Opera: -o-</p>
<h3 id="CSS3选择器"><a href="#CSS3选择器" class="headerlink" title="CSS3选择器"></a>CSS3选择器</h3><p>丰富选择的目的是为了减少class和id属性的使用</p>
<p>-1.属性选择器</p>
<p>-2.结构性伪类</p>
<p>  1)：root 匹配html标签，与body选择器效果一样</p>
<p>  2)：子元素选择 </p>
<p>​    -匹配父元素连续的子元素 :first-child | :last-child | :nth-last-child(n) | :nth-child(n)</p>
<ul>
<li><p>:only-child 查找父元素中仅有一个子元素</p>
</li>
<li><p>:only-of-type 查找父元素中仅有一个兄弟元素</p>
</li>
<li><p>:empty 查找没有元素（包含文本元素） ，即查找空元素  </p>
</li>
</ul>
<p>-3.目标伪类</p>
<ul>
<li>:target 匹配URL指向的元素</li>
</ul>
<p>-4.UI元素（表单元素）状态伪类</p>
<ul>
<li> :enabled 匹配form中 含有enabled属性的元素</li>
</ul>
<ul>
<li> :disabled 匹配form中 不含有enabled属性的元素</li>
</ul>
<ul>
<li> :checked 匹配form中处于选中状态的元素（Tips：只在Opera中生效）</li>
</ul>
<ul>
<li> :selection 匹配被用户选中的部分</li>
</ul>
<p>-5.否定伪类</p>
<ul>
<li>  :not 匹配所有不匹配前面简单选择器的元素</li>
</ul>
<p>-6.通用兄弟元素选择器</p>
<ul>
<li>  a~b 匹配a元素之后的b元素</li>
</ul>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3第二天（文本、边框）</title>
    <url>/2021/06/03/CSS3%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%88%E6%96%87%E6%9C%AC%E3%80%81%E8%BE%B9%E6%A1%86%EF%BC%89/</url>
    <content><![CDATA[<h3 id="CSS3文本"><a href="#CSS3文本" class="headerlink" title="CSS3文本"></a>CSS3文本</h3><p> -1.文本阴影 </p>
<p>​    语法：text-shadow：h-shadow v-shadow blur color</p>
<p>​    属性值：</p>
<ul>
<li><p>h-shadow{number} ：必需 水平阴影的位置 允许负值</p>
</li>
<li><p>v-shadow{number} ：必需 垂直阴影的位置 允许负值</p>
</li>
<li><p>blur{number} ：可选 模糊的距离</p>
</li>
<li><p>color{color} ：可选 阴影的位置</p>
</li>
<li><span id="more"></span></li>
<li><p>2.文本自动换行 </p>
</li>
</ul>
<p>​     语法：word-wrap：normal | break-word</p>
<p>​     属性值：</p>
<ul>
<li> normal ：只在有符号断开的地方换行 （默认）</li>
<li> break-word ：在规定的长度下直接换行</li>
</ul>
<p>-3.单词拆分</p>
<p>​    语法：word-break：normal | break-all | keep-all</p>
<p>​    属性值：</p>
<ul>
<li>normal ：使用浏览器的默认的换行规则</li>
<li>break-all ：允许在单词内进行换行</li>
<li>keep-all ：只能在半角空格或连字符处换行</li>
</ul>
<p>-4.文本溢出 （重要）</p>
<ul>
<li><p>单行文本溢出：text-overflow: clip（修剪文本） | ellipsis（显示省略号来代替被修剪的文本） | string （使用给定的字符串来代表被修剪的文本）</p>
</li>
<li><p>多行文本溢出：(IE9以下的版本不支持，主要是谷歌支持)</p>
<p>​    display： -webkit-box</p>
<p>​    -webkit-box-orient：vertical</p>
<p>​    -webkit-line-clamp：行数</p>
<p>​    overflow：hidden；</p>
</li>
</ul>
<h3 id="CSS3边框"><a href="#CSS3边框" class="headerlink" title="CSS3边框"></a>CSS3边框</h3><p> -1.圆角边框</p>
<p>  语法：border-radius: 1-4 length | % / 1-4 length | % （次序：左上 右上 右下 左下 ，也是顺时针）</p>
<p>  四个方位的词：top-left | top-right | bottom-left | bottom-right</p>
<p> -2.边框阴影</p>
<p>  语法：box-shadow：h-shadow v-shadow blur spread（阴影尺寸） color inset（将外部阴影改为内部阴影）</p>
<p> -3.边框图片</p>
<p>  语法：border-image：source slice width outset repeat</p>
<p>  属性值：</p>
<ul>
<li>source ：图片路径</li>
<li>silce ：图片边框向内偏移量</li>
<li>width：图片边框宽度</li>
<li>outset：边框图像区域超出边框的量</li>
<li>repeat：图像边框是否应平铺（repeat）、铺满（round）、或拉伸（stretch）</li>
</ul>
]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>文本 边框</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3第二天（背景、颜色、渐变、盒模型）</title>
    <url>/2021/06/03/CSS3%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%88%E8%83%8C%E6%99%AF%E3%80%81%E9%A2%9C%E8%89%B2%E3%80%81%E6%B8%90%E5%8F%98%E3%80%81%E7%9B%92%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="CSS3背景"><a href="#CSS3背景" class="headerlink" title="CSS3背景"></a>CSS3背景</h3><p> -1.多重背景</p>
<p>  语法：background：背景色（1） 背景图片（1） 平铺方式（1） 位置（1），背景色（2）…..</p>
<span id="more"></span>

<p> -2.background-size 设定背景图像的尺寸</p>
<p>  语法： background-size ：length | precentage | cover | contain </p>
<p>  属性值：</p>
<ul>
<li>length：设置背景图像的高度和宽度，第一个值设置宽度，第二个设置高度，如果只设置一个值，那么第二个值会被设置为 auto</li>
<li>percentage：以父元素的百分比来设置背景图像的高度和宽度，用法和length一样</li>
<li>cover：把背景图像扩展至足够大，已使背景图像完全覆盖背景区域。背景图像的某部分也许无法显示在背景定位区域中。</li>
<li>contain：把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</li>
</ul>
<p>-3.backgronnd-origin 属性指定了背景图像的位置区域</p>
<p>  语法： background-origin ：padding-box（背景图像相对于内边框来定位） | border-box （相对于边框盒） | content-box （相对于内容框）</p>
<p>-4.background-clip 设定背景的绘制区域</p>
<p>  语法：background-clip：padding-box（背景图像相对于内边框来定位） | border-box （相对于边框盒） | content-box （相对于内容框）</p>
<h3 id="CSS3颜色"><a href="#CSS3颜色" class="headerlink" title="CSS3颜色"></a>CSS3颜色</h3><p>-1.rgba（r，g，b，a）</p>
<p>  属性值：</p>
<ul>
<li><p>r：红色 取值范围：0-255</p>
</li>
<li><p>g:  绿色 取值范围：0-255</p>
</li>
<li><p>b:  蓝色 取值范围：0-255</p>
</li>
<li><p>a:  不透明度  取值范围：0-1的一个小数</p>
</li>
<li><p>2.HSL （h，s，l）</p>
<p>属性值：</p>
</li>
<li><p>  h：色调 取值范围：0-360</p>
</li>
<li><p>  s：饱和度 取值范围：0-360</p>
</li>
<li><p>   l：亮度 取值范围：0-100%</p>
</li>
<li><p>3.HSLA （h，s，l，a）</p>
<p>属性值：</p>
</li>
<li><p>  h：色调 取值范围：0-360</p>
</li>
<li><p>  s：饱和度 取值范围：0-360</p>
</li>
<li><p>   l：亮度 取值范围：0-100%</p>
</li>
<li><p>   a：不透明度 取值范围：0-1的一个小数</p>
</li>
</ul>
<p>-4.Opacity 设置元素的不透明级别 大多数请况下用于做元素的遮罩效果</p>
<p>  语法： opacity：value | inherit</p>
<p>  取值：</p>
<ul>
<li><p>value：规定不透明度。从0.0（完全透明）到1.0（完全不透明）。</p>
</li>
<li><p>inherit：从父元素继承opacity属性的值</p>
<p>Tips：IE8及8以下的版本不支持opacity。兼容方式为：再添加一行代码来处理不兼容。</p>
<p>  代码：filter：alpha（opacity = 数值）  数值的范围：0-100</p>
</li>
</ul>
<h3 id="CSS3渐变"><a href="#CSS3渐变" class="headerlink" title="CSS3渐变"></a>CSS3渐变</h3><p>  主要用来设置背景或制作三维图</p>
<p>  -1.线性渐变</p>
<p>  语法： background：linear-gradient（direction（方向或角度），color-stop1，color-stop2，…..）;</p>
<p>  -2.径向渐变</p>
<p>  语法：background：radial-gradient（shape，size，center，start-color，….. ，last-color）; </p>
<p>  属性：</p>
<ul>
<li><p>shape ：形状 ellipse（椭圆 默认）| circle（圆）</p>
</li>
<li><p>size：渐变大小</p>
<p>farthest-corner：渐变的半径长度为从圆心到离圆心最远的角（默认）</p>
<p>closest-side：渐变的半径长度为从圆心到离圆心最近的边</p>
<p>closest-corner：渐变的半径长度为从圆心到离圆心最近的角</p>
<p>farthest-side：渐变的半径长度为从圆心到离圆心最远的边</p>
</li>
<li><p>center：位置</p>
<p>center：设置圆心在中心位置</p>
<p>top：设置圆心在顶部位置</p>
<p>bottom：设置圆心在底部位置</p>
<p>at 圆心横坐标 圆心纵坐标 ：设定圆心的位置在一个指定位置上</p>
</li>
<li><p>start-color：初始颜色</p>
</li>
<li><p>last-color： 结束颜色</p>
<p>-3.文字渐变 </p>
<p>  语法：background-image：线性渐变或径向渐变；</p>
<p>​             background-clip：text；</p>
<p>​             text-fill-color：transparent；</p>
<h3 id="CSS3盒模型"><a href="#CSS3盒模型" class="headerlink" title="CSS3盒模型"></a>CSS3盒模型</h3><p>  -1.box-sizing 允许你以某种方式定义某些元素，以适应指定的区域。</p>
<p>  语法：box-sizing：content-box / border-box  / inherit（火狐和谷歌低版本需要厂商前缀）</p>
<p>  属性：</p>
<ul>
<li>content-box：实际宽高为内容+边框+内边距</li>
<li>border-box：内容包括内边距和外边框</li>
<li>inherit：从父元素继承box-sizing的值</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>背景 颜色 渐变 盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5（初识）</title>
    <url>/2021/06/02/HTML5%EF%BC%88%E5%88%9D%E8%AF%86%EF%BC%89/</url>
    <content><![CDATA[<h3 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h3><p>   -增加了audio与video音频播放，抛弃了Flash</p>
<p>   -新增了canvas画布（绘画，制作动画、如小游戏开发等）</p>
<p>   -地理定位</p>
<p>   -增加了离线缓存</p>
<p>   -硬件加速</p>
<p>   -Web Socket（全双工通信）</p>
<p>   -增加本地存储</p>
<p>   -新增一些语义化标签</p>
<span id="more"></span>

<h3 id="网页布局标签"><a href="#网页布局标签" class="headerlink" title="网页布局标签"></a>网页布局标签</h3><p>   -header 页首</p>
<p>   -nav 导航栏</p>
<p>   -aside 侧边栏</p>
<p>   -main 主体</p>
<p>   -section 区块</p>
<p>   -airicle 文章</p>
<p>   -footer 页尾</p>
<p><img src="https://s1.imagehub.cc/images/2021/06/02/050a3552f6f4334305.png" alt="050a3552f6f4334305.png"></p>
<h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>   -mark 高亮显示</p>
<p>   -summary（摘要）与detail（描述） 一般用于名词解释或用于封装一个区块</p>
<p>   -meter 定义度量衡 </p>
<p>​    -属性：value 当前值 | min{number}最小值 |max{number}最大值|low与high{number} 指范围的最大最小</p>
<p>   -progress 进度条 与meter属性用法一致</p>
<p>   -dialog 定义对话框或窗口</p>
<p>   -figure 用于对元素组合 （一般用来组合图片标题、图片与图片描述等）</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
  </entry>
  <entry>
    <title>HTML5（多媒体与画布）</title>
    <url>/2021/06/02/HTML5%EF%BC%88%E5%A4%9A%E5%AA%92%E4%BD%93%E4%B8%8E%E7%94%BB%E5%B8%83%EF%BC%89/</url>
    <content><![CDATA[<h4 id="audio-播放音乐或音频，IE9以下不支持"><a href="#audio-播放音乐或音频，IE9以下不支持" class="headerlink" title="audio 播放音乐或音频，IE9以下不支持"></a>audio 播放音乐或音频，IE9以下不支持</h4><p>   支持的格式：.mp3/.ogg/.wav</p>
<span id="more"></span>

<p>   属性：</p>
<p>​    -src 文件路径</p>
<p>​    -autplay 自动播放</p>
<p>​    -loop 循环</p>
<p>​    -controls 控制条</p>
<p>​    -muted 静音</p>
<p>​    -preload 预加载 （当使用autplay时 ，preload自动失效）</p>
<h4 id="video-加载视频-IE9以下不支持"><a href="#video-加载视频-IE9以下不支持" class="headerlink" title="-video 加载视频 IE9以下不支持"></a>-video 加载视频 IE9以下不支持</h4><p>​    </p>
<p>   支持的格式：.mp4/.ogg/.WemB</p>
<p>   属性：</p>
<p>​    -src 文件路径</p>
<p>​    -autplay 自动播放</p>
<p>​    -loop 循环</p>
<p>​    -controls 控制条</p>
<p>​    -muted 静音</p>
<p>​    -preload 预加载 （当使用autplay时 ，preload自动失效）</p>
<p>​    -width 宽度</p>
<p>​    -height 高度</p>
<p>​    -poster 海报</p>
<h4 id="embed-嵌入内容或加载插件"><a href="#embed-嵌入内容或加载插件" class="headerlink" title="embed 嵌入内容或加载插件"></a>embed 嵌入内容或加载插件</h4><p>   属性：</p>
<p>​    -src 文件路径</p>
<p>​    -width 宽度</p>
<p>​    -height 高度</p>
<p>​    -type 类型</p>
<p>​    </p>
<h4 id="canvas-画布-是一个容器元素"><a href="#canvas-画布-是一个容器元素" class="headerlink" title="canvas 画布 是一个容器元素"></a>canvas 画布 是一个容器元素</h4><p>   注意：</p>
<p>​    -单独使用canvas没有什么意义，它必须结合Javascript使用</p>
<p>​    -canvas的宽高最好不要通过CSS实现，而是直接使用标签属性width和height实现</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>多媒体与画布</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5（新增属性和组件）</title>
    <url>/2021/06/02/HTML5%EF%BC%88%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BB%84%E4%BB%B6%EF%BC%89/</url>
    <content><![CDATA[<h3 id="HTML5新增常用属性"><a href="#HTML5新增常用属性" class="headerlink" title="HTML5新增常用属性"></a>HTML5新增常用属性</h3><p>   -contentEditable 将标签转换为可编辑状态，可用于所有标签。默认值为false</p>
<p>   -hidden 对元素进行隐藏，一般用于传值或当某给条件成立时，执行内容显示</p>
<span id="more"></span>

<p>   -data-* 用于存储页面或应用程序的私有自定义数据，一般用于传值。</p>
<p>   -multiple 规定输入域中可选择多个内容，用于表单组件，如file/select。</p>
<p>   -required 约束表单元素在提交前必须输入值，用于表单组件中，需要结合提交按钮使用。</p>
<p>   -pattern 用于验证字段的模式，用于表单组件，需要结合提交按钮使用。</p>
<h3 id="HTML5部分新表单组件-input-type-“组件名”"><a href="#HTML5部分新表单组件-input-type-“组件名”" class="headerlink" title="HTML5部分新表单组件    input type=“组件名”"></a>HTML5部分新表单组件    input type=“组件名”</h3><p>   -color 颜色</p>
<p>   -email 邮箱</p>
<p>   -tel 电话号码</p>
<p>   -url 网址</p>
<p>   -number 数字</p>
<p>   -range 范围</p>
<p>   -search 搜索</p>
<p>   -date 日期</p>
<p>   -datetime 日期时间</p>
<p>   -datatime-local 本地日期时间</p>
<p>   -year 年份</p>
<p>   -month 月份</p>
<p>   -time 时间</p>
<h3 id="HTML5表单属性"><a href="#HTML5表单属性" class="headerlink" title="HTML5表单属性"></a>HTML5表单属性</h3><p>   -formaction 修改action数据提交的地方</p>
<p>   -formenctype 修改表单请求的类型</p>
<p>   -formmethod 修改数据提交的方法</p>
<p>​    常见的提交方式有get（默认）和post两种，他们的区别是：</p>
<ul>
<li>get以字节为单位提交，只接受ASCLL， 而post以字符为单位提交</li>
<li>get是明文方式，提交的数据会显示在地址栏中，一般不用来传输一些敏感的数据，而post是以暗文方式提交</li>
<li>get在浏览器中回退是无害的，而post会再次发送请求</li>
<li>get会被浏览器主动缓存，而post不会，除非手动设置</li>
<li>get和post在输出字节数上一般没有限制，个别浏览器有，可以理解get一般不超过2k，而post一般不超过2M</li>
</ul>
<p>   -form 设置表单元素属于哪个表单</p>
<p>   -novalidate 不验证</p>
<h3 id="input属性"><a href="#input属性" class="headerlink" title="input属性"></a>input属性</h3><p>   -autocomplete 自动完成</p>
<p>​    用来帮助用户输入，每一次输入的内容，浏览器是否保存输入的值，以备将来使用</p>
<p>​     属性值 on（默认）|off </p>
<p>​     为了保护敏感数据，避免本地浏览器对他们不安全存储，一般需要关闭</p>
<p>   -autofocus 自动获取焦点</p>
<p>   -step 步长</p>
<p>   -multiple 多选</p>
<p>   -pattern 正则匹配</p>
<p>   -placeholder 输入提示</p>
<p>   -required 必须输入</p>
]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
  </entry>
  <entry>
    <title>HTML与CSS面试题</title>
    <url>/2021/06/05/HTML%E4%B8%8ECSS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="HTML-CSS面试题"><a href="#HTML-CSS面试题" class="headerlink" title="HTML+CSS面试题"></a>HTML+CSS面试题</h1><ol>
<li><p>介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同</p>
<p>标准盒子模型： 宽度=content+border+padding+margin</p>
<p>低版本的盒子模型：宽度= 内容宽度（content+border+padding）+margin</p>
<span id="more"></span></li>
<li><p>CSS哪些属性可以被继承 | 哪些属性不可以被继承</p>
<p> font-size、font-family、color | border、padding、margin、width、height</p>
</li>
<li><p>样式权重 （权重相同，则选择最后出现的样式）</p>
<p>  !important（10000）&gt;内联样式（1000）&gt;id选择器（100）&gt;类、伪类选择器（10）&gt;标签择器（1）</p>
<p>（Tips：继承得到的样式的优先级最低）</p>
</li>
<li><p>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//div:</span><br><span class="line">margin: 0 auto;</span><br><span class="line"></span><br><span class="line">//浮动元素</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">margin: -50px 0 0 -100px;</span><br><span class="line"></span><br><span class="line">//绝对定位div</span><br><span class="line">position: absolute;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></table></figure></li>
<li><p>display有哪些值？说明他们的作用？</p>
<p>inline（默认） –内联</p>
<p>none –隐藏</p>
<p>block –块</p>
<p>table –表格</p>
<p>list-item –项目列表</p>
<p>line-block –行内块</p>
</li>
<li><p>CSS3新特性</p>
</li>
<li><p>解释CSS3的flexbox（弹性盒子布局模型），以及适用场景？</p>
<p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。</p>
<p>在传统的布局方式中，block布局在垂直方向从上到下依次排列；inline布局 则是在水平方向来排列；而弹性盒子布局没有这样内在的方向限制，由开发人员自由操作</p>
<p>适用场景：移动前端开发，在Android和ios上也完美支持。</p>
</li>
<li><p>用纯CSS创建一个三角形</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">border-top: 40px solid transparent;</span><br><span class="line">border-left: 40px solid transparent;</span><br><span class="line">border-right: 40px solid transparent;</span><br><span class="line">border-bottom: 40px solid #ff0000;</span><br><span class="line"></span><br><span class="line">//transparent 使其透明</span><br></pre></td></tr></table></figure></li>
<li><p>为什么要初始化CSS样式？</p>
<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p>
</li>
<li><p>absolute的containing block（包含块）计算方式跟正常流有什么不同？</p>
<p>无论哪种，都要先找到其祖先元素最近的position值不为static的元素再判断：</p>
<p>1.若此元素为inline元素，则containing block为 能包含这个元素生成的第一个和最后一个inline box 的padding box 的最小矩形。</p>
<p>2.否则，由这个祖先元素的 padding box 构成，如果都找不到，则为initial containing block。</p>
<p>（Tips：1.static / relative:就是父元素的content box</p>
<p>​               2.fixed：它的containing block 为当前的可视化窗口 ）</p>
</li>
<li><p>CSS中的visibility属性中有个collapse属性值，在不同浏览器下有什么区别？</p>
<p>当一个元素的visibility属性被设置成collapse后，对于一般的元素，表现和hidden一样</p>
<p>区别：</p>
<p>​        1.chrome中，使用collapse值和使用hidden没有区别</p>
<p>​        2.firefix，opera和IE，使用collapse值和使用display：none没有区别</p>
</li>
<li><p>display：none与visibility：hidden的区别？</p>
<p>前者不显示对应元素，文档布局中不再分配空间 | 后者隐藏对应元素，文档布局仍保留原来的空间。</p>
</li>
<li><p>BFC规范的理解</p>
</li>
<li><p>为什么会出现浮动和什么时候要清除浮动？清除浮动的方式？</p>
<p>浮动元素，会脱离文档流，漂浮在文档流的块框上</p>
<p>浮动带来的问题：</p>
<ol>
<li><p>父元素高度无法被撑开，影响与父元素同层级元素</p>
</li>
<li><p>与浮动元素同级的非浮动元素会跟随其后</p>
</li>
<li><p>如果不是第一个元素浮动，将会影响页面显示的结构</p>
</li>
</ol>
</li>
<li><p>CSS优化、提高性能的方法有哪些？</p>
<ol>
<li><p>避免过度约束</p>
</li>
<li><p>避免后代选择器</p>
</li>
<li><p>避免链式选择器</p>
</li>
<li><p>使用紧凑语法</p>
</li>
<li><p>避免不必要的命名空间</p>
</li>
<li><p>避免不必要的重复</p>
</li>
<li><p>最好使用表示语义的名字，一个好的类名应该是描述他是什么而不是像什么</p>
</li>
<li><p>避免！important，可以选择其他选择器</p>
</li>
<li><p>尽可能的精简规划，可以合并不同类里的合并规则</p>
</li>
</ol>
</li>
<li><p>浏览器是怎么样解析CSS选择器的？</p>
<ol>
<li><p>CSS选择器的解析是从右向左解析的。因为从左向右解析发现错误需要进行回溯，会损失很多性能，若从右向左，可以在第一步就筛选掉大量不符合条件的最右节点。</p>
</li>
<li><p>CSS解析完毕后，需要将解析的结果和DOM树的内容一起分析建立成一颗Render树，最终用来进行绘图。</p>
</li>
</ol>
</li>
<li><p>在网页中应该使用奇数还是偶数字体？</p>
<p>使用偶数字体，因为偶数字号相对更容易和web设计的其他部分构成比例关系。有的字体开始只提供了12、14、16px这三个大小的点阵，而13、15、17px时，用的是小一号的点，但是点阵没变，于是略显稀疏。</p>
</li>
<li><p>什么是响应式布局？响应式布局设计的基本原理是什么？</p>
<ol>
<li><p>响应式网站设计是一个网站能兼容多个终端，而不是每一个终端做一个特定的版本。</p>
</li>
<li><p>基本原理是通过媒体查询检测不同的设备尺寸做处理。</p>
</li>
<li><p>兼容IE的话 页面的头部必须有meta声明的viewport</p>
</li>
</ol>
</li>
<li><p>::before和::after中双冒号和单冒号有什么区别？</p>
<p>单冒号用于CSS3伪类，双冒号用于CSS3伪元素。</p>
<p>：before和：after两个伪元素，是在CSS2.1里新出现的。起初伪元素的前缀使用的是单冒号语法，但随着Web进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号。</p>
</li>
<li><p>你对line-height是如何理解的</p>
<p>行高是指一行文字的高度，具体说是两行文字间基线的距离</p>
<p>多行文本垂直居中，需要设置display属性为inline-block</p>
</li>
<li><p>如果需要手动画动画，你认为最小时间间隔是多少？</p>
<p>多数显示屏默认频率是60Hz，理论间隙最小位1/60*1000ms=16.7ms</p>
</li>
<li><p>display:inline-block什么时候会显示间隙？</p>
<ol>
<li><p>有空格时候会有间隙 解决：移除空格</p>
</li>
<li><p>margin正值的时候 解决：margin使用负值</p>
</li>
</ol>
</li>
<li><p>png、jpg、gif图片格式解释，分别什么时候用，以及webp</p>
<ol>
<li><p>png是便携式网络图片，是一种无损数据压缩的格式，优点是：压缩比搞，色彩好，大多数情况可以用</p>
</li>
<li><p>jpg是一个针对照片使用的一种失真压缩方法，是一个破坏性压缩，在www上，被用来存储和传输照片的格式</p>
</li>
<li><p>gif是一个位图文件格式，以8为色重现真色彩的图像，可以实现动画效果</p>
</li>
<li><p>webp格式是谷歌在2010年推出的，压缩略只有jpg的2/3，大小比png小了45%。缺点是压缩的时间更久了，兼容性不好。</p>
</li>
</ol>
</li>
<li><p>style标签写在body后与body前有什么区别?</p>
<p>页面加载自上而下，写在body标签后，由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表，会导致浏览器停止之前的渲染，等待加载且解析样式表完成后重新渲染，在windows的IE下可能会出现页面闪烁的情况。</p>
</li>
<li><p>CSS的overflow属性定义移除内容区的内容会如何处理？</p>
<ol>
<li><p>参数：scroll | 出现滚动条</p>
</li>
<li><p>参数：auto | 子元素内容大于父元素时出现滚动条</p>
</li>
<li><p>参数：visible | 溢出的内容出现在父元素之外</p>
</li>
<li><p>参数：hidden | 溢出隐藏</p>
</li>
</ol>
</li>
<li><p>阐述一下CSS Sprites</p>
<p>小精灵图，讲一个页面涉及到的所有图片都包含到一个大图中去，然后利用CSS中的background组合属性进行背景定位，利用CSS Sprites能很好的减少网页的http请求，从而大大的提高页面的性能；减少图片的字节。</p>
</li>
<li><p>DOM加载的流程</p>
<ol>
<li><p>解析HTML结构</p>
</li>
<li><p>加载外部脚本和样式表</p>
</li>
<li><p>解析并执行脚本代码</p>
</li>
<li><p>DOM树建立完成</p>
</li>
<li><p>加载图片等外部文件</p>
</li>
<li><p>页面加载完毕</p>
</li>
</ol>
</li>
<li><p>px、rem、rm</p>
<ul>
<li><p>px：px说我是固定的，不会变通</p>
</li>
<li><p>em/rem：我们是相对长度，页面布局变我们就变，响应式布局最喜欢我们了</p>
</li>
</ul>
<ol>
<li><p>px特性：IE无法调整使用px作为单位的字体大小 | 国内大部分使用的IE内核，FireFix能调整px、rem、em | px是相对屏幕分辨率而言的</p>
</li>
<li><p>em特性：可以继承父级元素的文字大小且em的值不固定</p>
</li>
<li><p>rem特性：集相对大小与绝对大小的优点于一身，既可以修改根元素比例来调整字体，也可以避免字体大小逐层符合的连锁。</p>
<p>（Tips：不支持rem的浏览器，可以多写一个绝对单位声明，浏览器会自动忽视rem设定的字体大小）</p>
</li>
</ol>
</li>
<li><p>link与@import的区别</p>
<ol>
<li><p>从属关系的区别：</p>
<ul>
<li>@import是CSS提供的语法规则，只有导入CSS样式表的功能</li>
<li>link是HTML提供的标签，不仅加载CSS，还可以定义RSS、rel、连接属性等</li>
</ul>
</li>
<li><p>加载顺序的区别：</p>
<p>加载页面时，link引入的CSS同时被加载 | @import引入的CSS在页面加载完后加载</p>
</li>
<li><p>兼容性区别：</p>
<p>@import在CSS2.1才有，IE5+才能识别；link属于HTML标签，不存在兼容问题</p>
</li>
<li><p>DOM可操作性区别：</p>
<p>DOM可以通过js操作link来改变样式，但是DOM是基于文档的，无法通过@import改变样式</p>
</li>
<li><p>权重区别</p>
</li>
</ol>
<p>  ​      link &gt; @import 的样式</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>HTML、CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序面试题</title>
    <url>/2021/06/06/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="小程序面试题"><a href="#小程序面试题" class="headerlink" title="小程序面试题"></a>小程序面试题</h1><ol>
<li><p>小程序的优势</p>
<p>无需下载安装，直接使用，运行速度快，项目搭建迅速，短小精悍，每个app源代码不超过</p>
<p>2MB</p>
<span id="more"></span></li>
<li><p>小程序的页面构成（4个文件）</p>
<p>index.js | index.json | index.wxml | index.wxss</p>
</li>
<li><p>小程序的生命周期</p>
<ol>
<li><p>onLoad（option） 页面加载时触发，只会调用一次，可获取当前页面路径中的参数</p>
</li>
<li><p>onShow（） 页面显示 /切换前台时触发，一般用来发送数据请求</p>
</li>
<li><p>onReady（） 页面初次渲染完成时触发，只会调用一次，代表页面已经可以和视图层进行交互</p>
</li>
<li><p>onHide（） 页面隐藏 / 切入后台时触发，如底部tab切换到其他页面或小程序切入后台等 </p>
</li>
<li><p>onUnload() 页面卸载时触发，如redirectTo或navigateBack 到其他界面</p>
</li>
<li><p>onPullDownRefresh（） 用户下拉时触发</p>
</li>
<li><p>onReachBottom（）用户上拉触底时触发</p>
</li>
<li><p>onshareTimeline（） 用户右上角点击转发</p>
</li>
</ol>
</li>
<li><p>小程序如何请求数据</p>
<p>用request</p>
</li>
<li><p>如何提高小程序的首屏加载时间</p>
<ol>
<li><p>提前请求：异步数据请求不需要等待页面渲染完成</p>
</li>
<li><p>利用缓存：利用storage API对异步请求数据进行缓存，二次启动时，先利用缓存数据渲染页面，再进行后台更新</p>
</li>
<li><p>避免白屏：先展示页面骨架和基础内容</p>
</li>
<li><p>及时反馈：及时的队需要用户等待交互操作给出反馈，避免用户以为小程序没有相应</p>
</li>
<li><p>性能优化：避免不当使用setData和onpagescroll</p>
</li>
</ol>
</li>
<li><p>Wxss与Css的区别</p>
<p>Wxss新增了尺寸单位rpx，提供了全新的全局样式和局部样式，Wxss仅支持部分Css选择器</p>
</li>
<li><p>小程序如何实现响应式</p>
<p>rpx</p>
</li>
<li><p>怎么优化小程序</p>
<ul>
<li><p>提高页面加载速度</p>
</li>
<li><p>用户行为预测</p>
</li>
<li><p>减少默认的data的大小</p>
</li>
<li><p>组件化方案</p>
</li>
<li><p>自主获知自己的服务器</p>
</li>
</ul>
</li>
<li><p>小程序如何显示用户头像与用户名</p>
<p>open-data 标签现在可以不用用户授权直接获取头像和用户名</p>
</li>
<li><p>请谈谈小程序的双向绑定和Vue的异同</p>
<p>Vue的双向绑定是通过数据拦截和观察者模式，通过this.value获取值，而小程序是通过触发表单元素绑定的方法，在js中用this.setData({ key:value})来取值</p>
</li>
<li><p>小程序中传参是怎么传的</p>
<p>在点击跳转的标签里，通过bindtap创建一个回调函数，且在标签中通过自定义属性绑定要传递的参数，拿到后，在跳转的API内的url后 +’’传递的参数’’，之后便可以在跳转到的页面里的onload声明周期里的option内拿到参数</p>
</li>
<li><p>小程序页面间有哪些传递数据的方法</p>
<ol>
<li><p>使用全局变量实现数据传递</p>
</li>
<li><p>页面跳转或重定向时，使用url带参数传递数据</p>
</li>
<li><p>使用组件模板template传递参数</p>
</li>
<li><p>使用缓存传递参数</p>
</li>
<li><p>使用数据库传递参数</p>
</li>
</ol>
</li>
<li><p>小程序数据请求的封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config.js</span></span><br><span class="line"><span class="comment">// 配置服务器相关信息</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">  <span class="attr">host</span>:<span class="string">&#x27;http://localhost:3000&#x27;</span>,</span><br><span class="line">  <span class="comment">// mobileHost:&#x27;http://huangxiaorui9527.cn.utools.club&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//request.js</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;./config&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (url,data=&#123;&#125;,method=<span class="string">&quot;GET&quot;</span>) =&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 1.new Promise 初始化promise实例的状态为pending</span></span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      <span class="attr">url</span>:config.host+url,</span><br><span class="line">      data,</span><br><span class="line">      method,</span><br><span class="line">      <span class="attr">header</span>:&#123;</span><br><span class="line">        <span class="attr">cookie</span>: wx.getStorageSync(<span class="string">&#x27;cookies&#x27;</span>)?wx.getStorageSync(<span class="string">&#x27;cookies&#x27;</span>).find(<span class="function"><span class="params">item</span> =&gt;</span> item.indexOf(<span class="string">&#x27;MUSIC_U&#x27;</span>) !== -<span class="number">1</span>):<span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.isLogin)&#123;</span><br><span class="line">          <span class="comment">// 登录请求 将cookie存入本地</span></span><br><span class="line">          wx.setStorage(&#123;</span><br><span class="line">            <span class="attr">key</span>: <span class="string">&#x27;cookies&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: res.cookies</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(res.data);<span class="comment">//修改Promise的状态为成功状态resolved</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function">(<span class="params">err</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;请求失败&#x27;</span>);</span><br><span class="line">        reject(err);<span class="comment">//修改promise的状态为失败状态rejected</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>小程序页面跳转的方式</p>
<ol>
<li><p>利用小程序的API跳转</p>
<ul>
<li>wx.navigateTo({ url }) 保留当前页面，跳转到应用的某个页面，使用wx.navigateBack可以返回到原页面,且不能跳到tabbar页面</li>
<li>wx.navigateBack 返回上一级或多级页面，可通过getcurrentpages获取当前页面栈，决定需要返回几层</li>
<li>wx.redirectTo 关闭当前页面，跳转到应用内某个页面去，但不允许跳转到tabbar页面</li>
<li>wx.reLaunch 关闭所有页面，打开到应用内的某个界面</li>
<li>wx.switchTab 跳转到tabBar页面，并关闭其他所有非tabBar页面</li>
</ul>
</li>
<li><p>利用小程序的组件跳转</p>
<p>navigator组件 利用open-type里的属性 naigate（默认）| redirect | switchTab | reLaunch</p>
</li>
</ol>
</li>
<li><p>谈一谈小程序主要目录和文件的作用</p>
<ol>
<li><p>project.config.json 项目配置文件，用得最多的就是配置是否开启https校验</p>
</li>
<li><p>App.js 设置一些全局的基础数据等</p>
</li>
<li><p>App.json 底部tab、标题栏和路由等设置</p>
</li>
<li><p>App.wxss 公共样式，引入iconfont等</p>
</li>
<li><p>pages 里面包含一个个具体的页面</p>
</li>
<li><p>index.json 配置当前页面标题和引入组件的等</p>
</li>
<li><p>index.wxss 页面样式表</p>
</li>
<li><p>index.wxml 页面结构</p>
</li>
<li><p>index.js 页面的逻辑，请求和数据处理等</p>
</li>
</ol>
</li>
<li><p>谈谈wxml与标准的html的异同</p>
<ul>
<li><p>都是用来描述页面的结构</p>
</li>
<li><p>都由标签和属性等构成</p>
</li>
<li><p>标签名字不一样，且小程序标签更少，单一标签更多</p>
</li>
<li><p>小程序多了一些wx：if这样的属性以及 { { } }这样的表达式</p>
</li>
<li><p>WXML仅能在微信小程序开发者工具中预览，而HTML可以在浏览器中预览</p>
</li>
<li><p>组件封装不痛，WXML对组件进行了重新封装</p>
</li>
<li><p>小程序在运行JS Core内，没有DOM树和window对象，小程序中无法使用window对象和document对象</p>
</li>
</ul>
</li>
<li><p>简述小程序原理</p>
<ul>
<li><p>小程序本质就是一个单页面应用，所有的页面渲染和事件处理，都在一个页面内进行，但又可以通过微信客户端调用原生的各种借口</p>
</li>
<li><p>它的架构是数据驱动的架构模式，它的UI和数据是分离的，所有的页面更新，都需要通过对数据的更改来实现</p>
</li>
<li><p>它从技术讲和现有的前端开发差不多，采用javascript、wxml、wxss三种技术进行开发</p>
</li>
<li><p>功能可分为webview和appService两个部分</p>
<ul>
<li>webview可以用来展示UI，appService用来处理业务逻辑、数据及接口调用</li>
<li>两个部分在两个进程中运行，通过系统层JSBridge实现通信，实现UI的渲染、事件的处理等</li>
</ul>
</li>
</ul>
</li>
<li><p>小程序调用后台接口遇到哪些问题？</p>
<ol>
<li><p>数据大小限制，超过范围会直接导致整个小程序崩溃，除非重启小程序</p>
</li>
<li><p>小程序不可以直接渲染文章内容这类型的html文章，需要借助插件</p>
<p>（Tips：插件渲染会导致页面加载变慢，建议在后台对文章的内容的html进行过滤，后台直接处理批量替换p标签和div，然后其他的标签让插件来做）</p>
</li>
</ol>
</li>
<li><p>bindtap和catchtap的区别</p>
<ol>
<li><p>bind事件绑定不会阻止冒泡事件向上冒泡</p>
</li>
<li><p>catch事件绑定可以阻止冒泡事件向上冒泡</p>
</li>
</ol>
</li>
<li><p>小程序常见问题</p>
<ol>
<li>rpx：小程序的尺寸单位，规定屏幕为750rpx，可适配不同分辨率的屏幕</li>
<li>本地资源无法通过wxss获取</li>
<li>wx.navigateTo无法打开页面是因为，一个应该只能打开五个页面，请避免多层级的交互方式或使用wx.redirectTo</li>
<li>tabBar设置不显示是因为 <ul>
<li>tarBar中list的数量少于两项或超过五项</li>
<li>tabBar写法错误导致</li>
<li>tabBar没有写pagePath字段（程序启动后的第一个页面）</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面试题</title>
    <url>/2021/06/06/Javascript%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Javascript面试题"><a href="#Javascript面试题" class="headerlink" title="Javascript面试题"></a>Javascript面试题</h1><ol>
<li><p>Js数据类型有哪些？</p>
<ul>
<li><p>字符串 String</p>
</li>
<li><p>数值 Number</p>
</li>
<li><p>布尔 Boolean</p>
</li>
<li><p>空值 Null</p>
</li>
<li><p>未定义 Undefined</p>
</li>
<li><p>对象 Object （Tips：除了Object为引用数据类型，其余全为基本数据类型）</p>
<span id="more"></span></li>
</ul>
</li>
<li><p>Js中Null与Undefined的区别</p>
<ol>
<li><p>相同点：用if判断时，两者都会被转换成false</p>
</li>
<li><p>不同点：</p>
<ul>
<li>number转化的值不同，number（Null）转化为0，number（undefined）转化为NaN</li>
<li>Null代表一个只被定义了，但这个值是空值 | Undefined表示变量声明了但未赋值</li>
</ul>
</li>
</ol>
</li>
<li><p>闭包是什么？有什么特性？对页面会有什么影响</p>
<ul>
<li><p>通俗理解，一个外部函数包裹着一个内部函数，内部函数里引用了外部函数的数据，且外部函数被执行，就会产生闭包。</p>
</li>
<li><p>特点：函数嵌套函数 | 函数内部可以引用外部的参数和变量 | 被引用的参数和变量不会被垃圾回收机制回收</p>
</li>
<li><p>优点：变量长期驻扎在内存中 | 避免全局变量的污染 | 私有成员的存在</p>
</li>
<li><p>缺点：会造成内存泄漏（应该被清除的数据 还停留在内存中）</p>
</li>
</ul>
</li>
<li><p>Js中常见的内存泄漏：</p>
<ol>
<li><p>意外的全局变量</p>
</li>
<li><p>被遗忘的计时器或回调函数</p>
</li>
<li><p>脱离DOM的引用</p>
</li>
<li><p>闭包</p>
</li>
</ol>
</li>
<li><p>事件委托</p>
<ol>
<li><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</p>
</li>
<li><p>事件委托，称事件代理，是js中很常用的绑定事件的技巧，事件委托就是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当监听的植物，事件委托的原理就是DOM元素的事件冒泡。</p>
</li>
<li><p>Event.target 谁调用谁就是事件源</p>
</li>
</ol>
</li>
<li><p>什么是事件冒泡？</p>
<p>一个事件触发后，会在子元素和父元素之间传播，这种传播分为三个阶段</p>
<ol>
<li><p>捕获阶段：从Windows对象传导到目标节点（从外到里），这个阶段不会响应任何事件</p>
</li>
<li><p>目标阶段：在目标节点上触发</p>
</li>
<li><p>冒泡阶段：从目标节点传导会window对象（从里到外）</p>
<p>Tips:事件委托/事件代理就是利用事件的冒泡机制把里层需要响应的事件绑定到外层。</p>
</li>
</ol>
</li>
<li><p>本地存储于cookie的区别</p>
<p>由于cookie不太行，有着大小限制（4k左右），所以H5新增两个存储 localstorage | sessionstorage</p>
<ol>
<li><p>cookie：跟踪用户信息，小跟屁虫，一般记录用户密码，浏览器已关闭，就没了</p>
</li>
<li><p>loalstorage：永久存储，只要不删除，就会一直存储在浏览器中</p>
</li>
<li><p>sessionstorage：临时存储，当前窗口打开时有效，当前窗口关闭数据就没了。</p>
</li>
</ol>
</li>
<li><p>ES6新特性</p>
<p>const和let、模板字符串、模板字符串、箭头函数、函数的参数默认值、对象和数组的结构、for…of和for…in、ES6中的类</p>
</li>
<li><p>Let、Var、Const的区别</p>
<ol>
<li><p>Var声明的变量会挂在在Window上，且它的变量存在变量提升，同一作用域下Var可以声明同名变量，以上let和const都不可以</p>
</li>
<li><p>Let声明会形成块级作用域，let暂存死区</p>
</li>
<li><p>const声明也会形成块级作用域，且一旦声明必须赋值，不能用null占位，声明后不能再修改，如果声明的是复合类型数据，可以修改属性</p>
</li>
</ol>
</li>
<li><p>数组的方法有哪些？</p>
<ol>
<li>push（） 从后面添加元素，返回值为添加完后的数据的长度</li>
<li>arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素</li>
<li>arr.shift（）从前面删除元素，只能删除一个，返回值是删除的元素</li>
<li>arr.unshift（） 从前面添加元素，返回值是添加完后的数组的长度</li>
<li>arr.splice(i,n) 删除从i开始的那个元素，n是删除的个数。返回值是删除的元素</li>
<li>arr.concat() 连接两个数组，返回值为连接后的新数组</li>
<li>str.split() 将字符串转化为数组</li>
<li>arr.sort() 将数组进行排序，返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小进行排序的</li>
<li>arr.reverse() 将数字反转，返回值是反转后的数组</li>
<li>arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</li>
<li>arr.forEach(callback) 遍历数组，无return，即使有return，也不会返回任何值，并且会影响原来的数组</li>
<li>arr.map(callback) 映射数组（遍历数组），有return返回一个新数组</li>
<li>arr.filter(callback) 过滤数组，返回一个满足要求的数组</li>
</ol>
</li>
<li><p>什么是面向对象</p>
<p>面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节；这种思想是将数据作为第一位，这是对数据的一种优化，操作起来更加方便，简化了过程。</p>
<ul>
<li><p>Js本身没有class类型的，但是每个函数都有一个prototype属性，prototype指向一个对象，当函数作为构造函数时，prototype就起到类似于class的作用</p>
</li>
<li><p>面向对象有三个特点</p>
<ol>
<li><p>封装：隐藏对象的属性和实现细节，对外提供公共访问方式</p>
</li>
<li><p>继承：提高代码的复用性，继承是多态的前提</p>
</li>
<li><p>多态：是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>普通函数和构造函数的区别</p>
<ol>
<li><p>构造函数也是一个普通函数，创建方式和普通函数一样，但是构造函数习惯上首字母大写</p>
</li>
<li><p>调用方式不一样，普通函数直接调用，构造函数要用关键字new来调用</p>
</li>
<li><p>调用时，构造函数内部会创建一个新对象，也就是实例，而普通函数不会创建新对象</p>
</li>
<li><p>构造函数的内部this指向实例，普通函数的内部this指向调用函数的对象（没有对象调用，默认为window）</p>
</li>
<li><p>构造函数默认的返回值是创建的对象，普通函数的返回值是由return语句决定的</p>
</li>
<li><p>构造函数的函数名与类名相同</p>
</li>
</ol>
</li>
<li><p>原型、原型链、原型继承</p>
<ol>
<li><p>原型：任何一个对象实例都有一个原型，也叫做原型对象，这个原型对象由对象的内置属性 proto 指向它的构造函数的prottype指向的对象，即任何对象都是有一个构造函数创建的，但不是每一个对象都有prototype，只有方法才有prototype</p>
</li>
<li><p>原型链：原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<p>原型链的核心就是依赖对象的 proto 的指向,当需要自身不存在的属性时，就一层层的扒出创建对象的构造函数，知道Object，就没有 proto 指向了。因为 proto实质找的是prototype，所以我们只要找到这个链条上的构造函数的prototype。其中Object.prototype是没有 proto 属性的，它 ==null</p>
</li>
<li><p>原型继承：理由原型中的成员可以被和其相关的对象共享这一特性，可以实现继承，这种实现继承的方式，就叫做原型继承</p>
</li>
</ol>
</li>
<li><p>Promise的理解</p>
<ol>
<li><p>什么是Promise？</p>
<p>Promise是一种解决异步编程的方案，相比回调函数和事件更合理更强大，从语法上讲，promise是一个对象，从它可以获取异步操作的消息</p>
</li>
<li><p>Promise有三种状态</p>
<ul>
<li>pending 初识状态（等待状态）</li>
<li>fulfiled 成功状态</li>
<li>rejected 失败状态</li>
</ul>
</li>
<li><p>promise的两个特点</p>
<ul>
<li>promise对象的状态不受外界影响</li>
<li>promise的状态一旦改变就不会再变，任何时候都可以得到这个结果，状态不可逆</li>
</ul>
</li>
<li><p>promise的三个缺点</p>
<ul>
<li><p>无法取消Promise，一旦新建它就会立即执行，无法中途取消</p>
</li>
<li><p>如果不设置回调函数，Promise内部抛出的错误，不会反映到外部</p>
</li>
<li><p>当处于pending状态时，无法得知目前进展到了哪一个节点，是刚刚开始还是即将完成</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>我们用Promise来解决什么问题</p>
<ol>
<li><p>回调地狱：代码难以维护，常常第一个函数的输出是第二个函数的输入这种现象</p>
</li>
<li><p>Promise支持多并发请求，获取并发请求中的数据</p>
</li>
<li><p>Promise可以解决异步的问题，本身不能说Promise是异步的</p>
</li>
</ol>
</li>
<li><p>async的用法</p>
<ol>
<li><p>async就是generation和promise的语法糖，async就是将generator的*换成了async，将yiled换成了await</p>
</li>
<li><p>函数前必须加一个async，异步操作方法前加一个await关键字，意思就是等一下，执行完了再走（Tips：await只能在async函数中运行，否则会报错）</p>
</li>
</ol>
</li>
<li><p>一个页面从输入Url到页面加载显示完成，这个过程中都发生了什么</p>
<ol>
<li><p>当发送一个URl请求时，不管URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。（开启线程，启动DNS，以便获取IP）</p>
</li>
<li><p>浏览器与远程Web服务器通过TCP三次握手来建立一个TCP | IP 连接。该握手包括一个同步保温，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端建立起通信，然后服务端响应并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。</p>
</li>
<li><p>一旦TCP / IP 连接建立，浏览器会通过该连接会向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源</p>
</li>
<li><p>此时Web服务器提供资源服务，客户端开始下载资源</p>
</li>
</ol>
</li>
<li><p>get和post请求在缓存方面的区别</p>
<ul>
<li><p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</p>
</li>
<li><p>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存</p>
</li>
<li><p>因此get请求适合于请求缓存</p>
</li>
</ul>
</li>
<li><p>JS的语言特性</p>
<ol>
<li><p>运行在客户端的浏览器上</p>
</li>
<li><p>不用预编译，直接解析执行代码</p>
</li>
<li><p>是弱类型语言，较为灵活</p>
</li>
<li><p>与操作系统无关，跨平台的语言</p>
</li>
<li><p>脚本语言、解释性语言</p>
</li>
</ol>
</li>
<li><p>js的new操作符做了哪些事情</p>
<p>new操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数之后返回这个对象</p>
</li>
<li><p>改变函数内部this指针指向函数（bind，apply，call的区别）</p>
<p>通过apply和call改变函数的this指向，他们两个函数的第一参数都是表示要改变指向的那个对象，第二个参数apply是数组，而call则是arg1，arg2…这种形式。而通过bind改变this作用域会返回一个新的作用域，这个函数不会马上执行</p>
</li>
<li><p>js拖拽功能的实现</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            -可以拖拽box1元素</span></span></span><br><span class="line"><span class="comment"><span class="javascript">             -拖拽流程</span></span></span><br><span class="line"><span class="comment"><span class="javascript">               1.当鼠标在拖拽元素上按下时，开始拖拽 onmousedown</span></span></span><br><span class="line"><span class="comment"><span class="javascript">               2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove</span></span></span><br><span class="line"><span class="comment"><span class="javascript">               3.当鼠标松开时，被拖拽元素固定在当前 onmouseup</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            */</span> </span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取box1</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> box1=<span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 为box1绑定一个鼠标按下事件</span></span></span><br><span class="line"><span class="javascript">            box1.onmousedown=<span class="function"><span class="keyword">function</span>(<span class="params">on</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                on=on||<span class="built_in">window</span>.on;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 求出div水平偏移量Left 鼠标.clentX-元素.offsetLeft</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// 求出div垂直偏移量Top 鼠标.clentY-元素.offsettop</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> Left=on.clientX-box1.offsetLeft;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> Top=on.clientY-box1.offsetTop;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="comment">//为document绑定一个onmousemove事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove 需要获取鼠标坐标</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                    event=event||<span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 获取鼠标坐标</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> left=event.clientX-Left;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> top=event.clientY-Top;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 修改box1位置</span></span></span><br><span class="line"><span class="javascript">                    box1.style.left=left+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    box1.style.top=top+<span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="javascript">                &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmouseup=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 取消onmousemove事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmousemove=<span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 取消自己 可以当这个操作变成一次性事件</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.onmouseup=<span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            -当我们拖拽一个网页内容时，浏览器会默认去搜索引擎中搜索内容</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            -此时会导致 拖拽功能异常，这个是浏览器提供的默认行为</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            如果不希望发生这个行为 则可以通过return false来取消默认行为</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            </span></span></span><br><span class="line"><span class="comment"><span class="javascript">            但是对IE8不起作用</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            */</span> </span></span><br><span class="line"><span class="javascript">           <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固CSS第一天（CSS引用方式）</title>
    <url>/2021/06/01/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88CSS%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<p>CSS层叠样式表，用来美化网页。做到结构（HTML）和表现（CSS）分离</p>
<p>​      基本语法：选择器 {</p>
<p>​         属性: 属性值;</p>
<p>​         }</p>
<p>​     </p>
<h3 id="CSS引用方式-：-行间样式、内部样式、外部样式、导入外部样式。"><a href="#CSS引用方式-：-行间样式、内部样式、外部样式、导入外部样式。" class="headerlink" title="CSS引用方式 ： 行间样式、内部样式、外部样式、导入外部样式。"></a>CSS引用方式 ： 行间样式、内部样式、外部样式、导入外部样式。</h3><p>​       <span id="more"></span></p>
<p>​       行间样式：直接在标签书写样式</p>
<p>​       内部样式：在文件的内部书写样式</p>
<p>​       外部样式：先创建CSS文件，再用link标签引入这个文件</p>
<p>​       导入外部样式： 先创建CSS文件 ，在再style标签中用import导入这个样式文件</p>
<p>​    </p>
<p>​     以上四种引入方式的区别是：行内样式只作用于当前标签；内部样式作用于当前文件；外部样式可以被多个HTML文件引用</p>
<p>​     在实际开发中，最好使用外部样式。</p>
<h4 id="外部样式分为link和import引入方式，区别是"><a href="#外部样式分为link和import引入方式，区别是" class="headerlink" title="外部样式分为link和import引入方式，区别是"></a>外部样式分为link和import引入方式，区别是</h4><p>​       1.link是XHTML标签，除了加载css外，还可以定义RSS等其他事务；@import属于css范畴，只能加载css</p>
<p>​       2.link引入css时，在页面载入时同时加载；而@import需要页面网页完全载入以后加载</p>
<p>​       3.link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持</p>
<p>​       4.link支持使用javascript控制DOM去改变样式；而@import不支持</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固CSS第一天（CSS样式）</title>
    <url>/2021/06/01/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88CSS%E6%A0%B7%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h3 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h3><h4 id="样式权重："><a href="#样式权重：" class="headerlink" title="样式权重："></a>样式权重：</h4><p>​     !important（10000）&gt;内联样式（1000）&gt;id选择器（100）&gt;类、伪类选择器（10）&gt;标签选择器（1）</p>
<h4 id="CSS字体属性："><a href="#CSS字体属性：" class="headerlink" title="CSS字体属性："></a>CSS字体属性：</h4><p>​      1.font-size：字号</p>
<p>​       属性值：<code>&#123;</code>number+px<code>&#125;</code> 固定值尺寸像素 /<code> &#123;</code>number+%<code>&#125;</code> 其百分比取值是基于父对象中字体尺寸大小</p>
<p>​      2.font-family：字体</p>
<p>​       属性值：name 字体名称，按优先顺序排列，以逗号隔开，如果字体包含空格，则应使用引号包裹</p>
<p>​           如果浏览器都识别不了，浏览器会给它添加默认的字体</p>
<span id="more"></span>

<p>​      3.font-style：样式</p>
<p>​       属性值：normal 默认值 正常字体</p>
<p>​           italic：斜体，对于没有斜体变量的特殊字体，将应用oblique</p>
<p>​           oblique: 倾斜的字体</p>
<p>​      4.font-weight：加粗</p>
<p>​       属性值：normal 默认值</p>
<p>​           bold 粗体</p>
<p>​           bolder 比bold粗</p>
<p>​           lighter 比normal细</p>
<p>​           {100-900} 400约为normal 700约为bold</p>
<p>​           </p>
<p>​      5.line-height：行高</p>
<p>​       属性值：normol 默认值</p>
<p>​           {number+px} 指定行高像素</p>
<p>​           {number} 指定行高为字体倍数</p>
<p>​      6.color：文字的颜色</p>
<p>​       属性值：name 颜色名称指定color</p>
<p>​           rgb 指定颜色为RGB值</p>
<p>​           { 颜色16进制} 指定颜色为16进制</p>
<p>​      7.text-decoration：文字的修饰</p>
<p>​       属性值：normal 默认值</p>
<p>​           underline 下划线</p>
<p>​           line-through 贯穿线</p>
<p>​           overline 上划线</p>
<p>​      8.text-align：文本对齐方式</p>
<p>​        属性值：left 默认值</p>
<p>​            center 居中对齐</p>
<p>​            right 右对齐</p>
<p>​      9.text-transform：字母大小写</p>
<p>​       属性值：none 默认值 无转换发生</p>
<p>​           capitalize 将每个单词的第一个字母转换为大写</p>
<p>​           uppercase 所有字母转换为大写</p>
<p>​           lowercase 所有字母转换为小写</p>
<p>​      10.text-indent：文本缩进</p>
<p>​       属性值：{number+px} 首行缩进number像素</p>
<p>​           {number+em} 首行缩进number字符 跟文字大小来确定</p>
<p>​      </p>
<p>​      11.font-variant</p>
<p>​       属性值：normal 默认值</p>
<p>​           small-caps 浏览器会显示小型的大写字母字体</p>
<p>​           inherit 规定从父元素继承font-variant的值</p>
<h4 id="font的复合属性"><a href="#font的复合属性" class="headerlink" title="font的复合属性"></a>font的复合属性</h4><p>​     次序：font-style font-variant font-weight font-size/line-height font-family；</p>
<p>​     注意：</p>
<p>​      1) 属性值的位置顺序</p>
<p>​      2) 除了font-size和font-family之外，其它任何一个值都可以省略</p>
<h4 id="CSS背景："><a href="#CSS背景：" class="headerlink" title="CSS背景："></a>CSS背景：</h4><p>​       1.background-color：背景色（transparent/color）</p>
<p>​       2.background-image：背景图（none/url）</p>
<p>​       3.background-repeat：背景图像铺排方式（repeat/no-repeat/repeat-x/repeat-y）</p>
<p>​       4.background-position: 设置对象的背景图像位置 两个参数</p>
<p>​        {x-number|top|center|bottom} {y-number|left|center|right} 如果只带一个参数，默认另一个为50%</p>
<p>​       5.background-attachment：设置对象背景滚动位置（scroll/fixed）</p>
<p>​       6.background:设置背景的符合写法</p>
<p>​        次序为：color image repeat attachment position</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固CSS第一天（CSS选择器）</title>
    <url>/2021/06/01/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88CSS%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><h4 id="CSS选择器分类："><a href="#CSS选择器分类：" class="headerlink" title="CSS选择器分类："></a>CSS选择器分类：</h4><p>​      1) * ：匹配HTML中所有元素（注意：*性能差，因为他要匹配所有元素）</p>
<p>​      2) 标签选择器 ：匹配对应标签</p>
<p>​      3) 类选择器 ：选择class命名的标签</p>
<p>​      4) ID选择器 ：选择用id命名的标签</p>
<p>​      5) 派出选择器 ：根据上下文来确定要选择的标签</p>
<span id="more"></span>

<p>​      6) 伪类选择器 ：</p>
<p>​         伪类：专门用来表示元素一种的特殊状态。</p>
<p>​          常用的伪类选择器：</p>
<p>​           -a标签的伪类：</p>
<p>​            –:link 未访问状态</p>
<p>​            –:visited 已被访问状态</p>
<p>​            –:hover 鼠标悬停状态</p>
<p>​            –:active 用户激活</p>
<p>​           </p>
<p>​           -表单 :focus 获得焦点</p>
<p>​           -:first-child/:last-child/:nth-child(number) </p>
<p>​      7) 属性选择器：</p>
<p>​          [属性名]：包含有指定属性名的元素 （常用）</p>
<p>​          [属性名=值]：属性名的值 为指定值的元素 （常用）</p>
<p>​          [属性名~=值]：属性名的值 包含指定值的元素</p>
<p>​          [属性名^=值]：属性名的值 以指定值开头的元素</p>
<p>​          [属性名&amp;=值]：属性名的值 以指定值结尾的元素</p>
<p><img src="https://s1.imagehub.cc/images/2021/06/02/04fb6bf1a5f8664b6c.png" alt="04fb6bf1a5f8664b6c.png"></p>
<p>​      8) 关系选择器</p>
<p>​         -空格 后代选择器</p>
<p>​         -&gt; 表示只选择儿子元素，孙子等元素不参与选择</p>
<p>​         -+ 兄弟选择器</p>
<h4 id="CSS选择器的分组："><a href="#CSS选择器的分组：" class="headerlink" title="CSS选择器的分组："></a>CSS选择器的分组：</h4><p>​      让多个选择器（元素）具有相同样式，一般用于设置公共样式</p>
<h4 id="CSS选择器的继承："><a href="#CSS选择器的继承：" class="headerlink" title="CSS选择器的继承："></a>CSS选择器的继承：</h4><p>​      子元素可以继承父元素的样式，反之不行</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固CSS第一天（伪类与伪元素）</title>
    <url>/2021/06/01/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0%EF%BC%89/</url>
    <content><![CDATA[<h3 id="CSS伪元素"><a href="#CSS伪元素" class="headerlink" title="CSS伪元素"></a>CSS伪元素</h3><h4 id="CSS伪元素与伪类的区别"><a href="#CSS伪元素与伪类的区别" class="headerlink" title="CSS伪元素与伪类的区别"></a>CSS伪元素与伪类的区别</h4><p>​      CSS引入伪元素和伪类概念是为了格式化文档以外的信息。也就是说伪类和伪元素是用来修饰不在文档树中的部分</p>
<p>​      伪类：用于当已有元素处于某个状态，为其添加对应样式，这个样式是根据用户行为而动态变化的。它只有处于dom文档树</p>
<p>​      无法描述的状态下才能为其添加样式，所以将其称为伪类。</p>
<p>​      伪元素：用于创建一些不在文档树中的元素，并为其添加样式。用户虽然可以看到文本，但文本实际不存在文档树中。</p>
<span id="more"></span>



<h4 id="伪类与伪元素的特点："><a href="#伪类与伪元素的特点：" class="headerlink" title="伪类与伪元素的特点："></a>伪类与伪元素的特点：</h4><p>​       -伪元素和伪类都不会出现在源文档或者文档树中</p>
<p>​       -伪元素允许出现在选择器的任何位置，而一个伪元素只能跟在最后一个简单选择器后面</p>
<p>​       -伪类名和伪元素名都是对大小写不敏感的</p>
<p>​       -有些伪类互斥，而不互斥的可以用在同一个元素上</p>
<h4 id="伪元素注意的点："><a href="#伪元素注意的点：" class="headerlink" title="伪元素注意的点："></a>伪元素注意的点：</h4><p>​       :before/:after/:first-letter（第一个字）/first-line（第一行） 这些前面可以是一个冒号 也可以是双冒号</p>
<p>​       ::selection/::placeholder/::backdrop 这些前面只能是双冒号</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>伪类与伪元素</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固CSS第一天（table与列表样式）</title>
    <url>/2021/06/01/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88table%E4%B8%8E%E5%88%97%E8%A1%A8%E6%A0%B7%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="table样式与列表样式"><a href="#table样式与列表样式" class="headerlink" title="table样式与列表样式"></a>table样式与列表样式</h2><h3 id="table样式：-table一般不用来布局，主要用来格式化数据"><a href="#table样式：-table一般不用来布局，主要用来格式化数据" class="headerlink" title="table样式： table一般不用来布局，主要用来格式化数据"></a>table样式： table一般不用来布局，主要用来格式化数据</h3><h4 id="属性："><a href="#属性：" class="headerlink" title="-属性："></a>-属性：</h4><p>​        width：宽度</p>
<p>​        height：高度</p>
<p>​        border-collapse：collapse；单线边框</p>
<p>​        border：边框线</p>
<p>​    <span id="more"></span></p>
<h4 id="tr，td属性："><a href="#tr，td属性：" class="headerlink" title="tr，td属性："></a>tr，td属性：</h4><p>​        width：宽度</p>
<p>​        height：高度</p>
<p>​        border：边框线</p>
<p>​        text-align：文本左右对齐（left|center|right）</p>
<p>​        vertical-align：文本垂直对齐（top|botom|imddle 默认 ）</p>
<p>​       </p>
<h3 id="列表样式：-不是描述性文本的任何内容都可以认为是列表。比如：菜单、商品列表等"><a href="#列表样式：-不是描述性文本的任何内容都可以认为是列表。比如：菜单、商品列表等" class="headerlink" title="列表样式： 不是描述性文本的任何内容都可以认为是列表。比如：菜单、商品列表等"></a>列表样式： 不是描述性文本的任何内容都可以认为是列表。比如：菜单、商品列表等</h3><h4 id="1-列表类型"><a href="#1-列表类型" class="headerlink" title="-1.列表类型"></a>-1.列表类型</h4><p>​      无序（ul）、有序（ol）、以及自定义列表（dl）</p>
<p>​      ul和ol的列表项都是由li表示的，而dl是由一个dt和一个或多个dd组成的</p>
<p>​      dl一般用来设定一个定义，比如名词解释。dt（标题）; dd（描述）,用来对dt的内容进行解释并说明</p>
<h4 id="2-样式（用来修改标识类型）"><a href="#2-样式（用来修改标识类型）" class="headerlink" title="-2.样式（用来修改标识类型）"></a>-2.样式（用来修改标识类型）</h4><p>​      list-style-image：用图像标识标识</p>
<p>​      list-style-position：标识的位置（inside|outside 默认 ）</p>
<p>​      list-style-type：标识类型</p>
<p>​        属性值：</p>
<p>​          a) 无序 disc（实心圆）|circle（空心圆）|square（实心矩形）</p>
<p>​          b) 有序 decimal（默认）|decimal-leading-zero|lower-roman|upper-roman|lower-alpha…</p>
<p>​          c）有序和无序 都有none 取消前面的标识</p>
<p>​        简写： list-style：list-style-image list-style-position list-style-type;  任意顺序，可以任意省略，只要提供一个值，其余值都会默认</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固CSS第一天（盒子模型）</title>
    <url>/2021/06/01/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><h3 id="每个元素都是一个盒子，一个盒子由margin（外边距），border（边框线），padding（内边框）和content（内容）组成"><a href="#每个元素都是一个盒子，一个盒子由margin（外边距），border（边框线），padding（内边框）和content（内容）组成" class="headerlink" title="每个元素都是一个盒子，一个盒子由margin（外边距），border（边框线），padding（内边框）和content（内容）组成"></a>每个元素都是一个盒子，一个盒子由margin（外边距），border（边框线），padding（内边框）和content（内容）组成</h3><span id="more"></span>

<h4 id="margin-外边距"><a href="#margin-外边距" class="headerlink" title="-margin 外边距"></a>-margin 外边距</h4><p>​     系统默认外边距为8px。</p>
<p>​     -margin：可以用来设置任意一个边的边距，可以带1至4个参数。</p>
<p>​      一个：（a px）表示上下左右都为a px</p>
<p>​      两个：（apx ，bpx）表示上下为apx，左右为bpx</p>
<p>​      三个：（apx ，bpx ，cpx）表示上外边距为apx，左右为bpx，下为cpx</p>
<p>​      四个： （apx ，bpx ，cpx， dpx） 依次为上 、右、 下、 左，顺时针</p>
<h4 id="padding-内边距-指元素的文本内容与边框之间的距离"><a href="#padding-内边距-指元素的文本内容与边框之间的距离" class="headerlink" title="-padding 内边距 指元素的文本内容与边框之间的距离"></a>-padding 内边距 指元素的文本内容与边框之间的距离</h4><p>​     padding：用法与margin完全一样</p>
<h4 id="border-边框"><a href="#border-边框" class="headerlink" title="-border 边框"></a>-border 边框</h4><p>​     border-width：边框线宽度</p>
<p>​     border-style：边框线样式</p>
<p>​     border-color：边框线颜色</p>
<h4 id="盒子的真实尺寸"><a href="#盒子的真实尺寸" class="headerlink" title="盒子的真实尺寸"></a>盒子的真实尺寸</h4><p>​     盒子宽度 = width+padding左右+border左右</p>
<p>​     盒子高度 = height+padding上下+border上下</p>
<h3 id="display属性：用来设置元素显示方式。"><a href="#display属性：用来设置元素显示方式。" class="headerlink" title="display属性：用来设置元素显示方式。"></a>display属性：用来设置元素显示方式。</h3><p>​     属性值：</p>
<p>​        none：不显示元素</p>
<p>​        block：块显示，在元素前后设置换行符，目的：将行级元素转换为块级元素</p>
<p>​        lnline：行内显示，将块级转换为行级</p>
<p>​        inline-block：将块级或行级标签转换为行内块标签</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>稳固CSS第一天（浮动）</title>
    <url>/2021/06/01/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E6%B5%AE%E5%8A%A8%EF%BC%89/</url>
    <content><![CDATA[<h2 id="什么是浮动？"><a href="#什么是浮动？" class="headerlink" title="什么是浮动？"></a>什么是浮动？</h2><p>​       浮动就是让块级标签不独占一行，使其脱离文档流，浮动的块级标签可以排成一行</p>
<p>​    </p>
<h3 id="浮动的原理："><a href="#浮动的原理：" class="headerlink" title="浮动的原理："></a>浮动的原理：</h3><p>​       就是让元素脱离文档流，不占用标准流。</p>
<span id="more"></span>

<p>​     float 属性值：left/right/none（默认值 不浮动）</p>
<p>​     浮动后，后面的元素不管是块级元素还是行级元素，都会补足脱离文档流元素之前的空隙（空隙足够大的情况下）。</p>
<h3 id="清除浮动：让后面的元素-不会来补足脱离文档流的元素之前的空隙"><a href="#清除浮动：让后面的元素-不会来补足脱离文档流的元素之前的空隙" class="headerlink" title="清除浮动：让后面的元素 不会来补足脱离文档流的元素之前的空隙"></a>清除浮动：让后面的元素 不会来补足脱离文档流的元素之前的空隙</h3><p>​      方法：</p>
<p>​        1.添加空标签，并设置样式：clear：both;</p>
<p>​      clear-left; 清除左浮动  clear-清除右浮动  clear-both 清除左右浮动</p>
<p>​         </p>
<p>​        2.在要清除浮动的父级添加样式：overflow：hidden;</p>
<p>​          overflow-hidden 它的意思是超出部分隐藏，也可以用来实现清除浮动。</p>
<p>​        </p>
<p>​        3.在要清除浮动的父级添加伪元素，并设定样式：</p>
<p>​          父元素:after{</p>
<p>​            content:””;</p>
<p>​            display:block;</p>
<p>​            clear:both;</p>
<p>​          }</p>
<p>​        注意，在实际项目开发中，我们首选第二种方法</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浮动</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固CSS第二天（定位、BFC与IFC）</title>
    <url>/2021/06/02/%E7%A8%B3%E5%9B%BACSS%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%88%E5%AE%9A%E4%BD%8D%E3%80%81BFC%E4%B8%8EIFC%EF%BC%89/</url>
    <content><![CDATA[<h3 id="定位-（position）设置元素在文档中的位置，会将标签（元素）转换为块级。"><a href="#定位-（position）设置元素在文档中的位置，会将标签（元素）转换为块级。" class="headerlink" title="定位 （position）设置元素在文档中的位置，会将标签（元素）转换为块级。"></a>定位 （position）设置元素在文档中的位置，会将标签（元素）转换为块级。</h3><h4 id="定位分类-（属性值）"><a href="#定位分类-（属性值）" class="headerlink" title="定位分类 （属性值）"></a>定位分类 （属性值）</h4><p>​     -static 静态定位 默认值 没有定位 不能设置偏移值 占用标准流</p>
<p>​     -relative 相对定位 占用标准流 可以通过偏移值改变其位置 相对自身所占位置做偏移</p>
<span id="more"></span>

<p>​     -absolute 绝对定位 会脱离文档流 可以通过偏移值改变其位置</p>
<p>​      绝对定位一般与相对定位结合使用，它相对设置了relative定位的父级做偏移，如果没有父级开启相对定位，则相对body做偏移</p>
<p>​     -fixed 固定定位 脱离文档流 相对于浏览器窗口左上角（0,0）做偏移，它与父级设不设定relative 没有关系</p>
<p>​      一般在开发中用来固定导航栏</p>
<h3 id="z-index-仅能在定位元素上奏效"><a href="#z-index-仅能在定位元素上奏效" class="headerlink" title="z-index 仅能在定位元素上奏效"></a>z-index 仅能在定位元素上奏效</h3><p>​     当多个元素添加绝对定位，元素将会叠加在一起，使用z-index可以设置元素显示的层次 普通流的z-index为0</p>
<h3 id="FC-（格式上下文）"><a href="#FC-（格式上下文）" class="headerlink" title="FC （格式上下文）"></a>FC （格式上下文）</h3><p>它是CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并有一套渲染规则,它决定了其子元素将如何定位，以及和其他元素的关系与相互作用。分为：BFC与IFC</p>
<h4 id="BFC：块级格式上下文"><a href="#BFC：块级格式上下文" class="headerlink" title="BFC：块级格式上下文"></a>BFC：块级格式上下文</h4><h5 id="形成BFC的条件"><a href="#形成BFC的条件" class="headerlink" title="-形成BFC的条件"></a>-形成BFC的条件</h5><p>​      -浮动元素（float除none以外的值）</p>
<p>​      -定位元素（值为absolute/fixed）</p>
<p>​      -display（值为inline-block/table-cell/table-caption）</p>
<p>​      -overflow（值为hidden/auto/scroll时）</p>
<h5 id="BFC特性"><a href="#BFC特性" class="headerlink" title="-BFC特性"></a>-BFC特性</h5><p>​      -内部的盒子会在垂直方向上一个接一个的位置</p>
<p>​      -垂直方向上的距离由块级元素之间的margin最大值决定 如果不想要这个特性，就将其变成成一个独立的BFC容器</p>
<p>​      -BFC的区域不会与float元素区域重叠</p>
<p>​      （如果一个元素不想和float重叠 可以在样式内加入overflow：hidden，形成BFC，这样就不会重叠了）</p>
<p>​      -计算BFC高度时，浮动元素也参与计算</p>
<p>​      （如果一个子元素浮动，没有元素来撑开父元素，可以使父元素变成BFC，这样父元素依然能被浮动的子元素撑开）</p>
<p>​      -BFC就是页面上一格独立的容器，容器里面的子元素不会影响到外面的元素</p>
<p>​     </p>
<h5 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="-BFC的作用"></a>-BFC的作用</h5><p>​      -解决margin重叠问题（添加独立BFC）</p>
<p>​      -解决高度塌陷问题（在父级元素中添加overflow：hidden）</p>
<p>​      -解决侵占浮动元素的问题（添加overflow：hidden清除浮动）</p>
<h4 id="IFC：内联（行级）格式上下文"><a href="#IFC：内联（行级）格式上下文" class="headerlink" title="IFC：内联（行级）格式上下文"></a>IFC：内联（行级）格式上下文</h4><h5 id="形成IFC的条件"><a href="#形成IFC的条件" class="headerlink" title="-形成IFC的条件"></a>-形成IFC的条件</h5><p>​      -font-size</p>
<p>​      -line-height</p>
<p>​      -height</p>
<p>​      -vertical-align</p>
<h5 id="IFC特性（规则）"><a href="#IFC特性（规则）" class="headerlink" title="-IFC特性（规则）"></a>-IFC特性（规则）</h5><p>​      -IFC的元素会在一行中从左至右排列</p>
<p>​      -在一行中的所有元素会在一个区域内形成一个行框</p>
<p>​      -行宽的高度为包含框的高度，高度为行框中的最高元素</p>
<p>​      -浮动的元素，不会在行框中，并且浮动元素会压缩行框的宽度</p>
<p>​      -行框的宽度容纳不下子元素时，子元素会自动换到下一行，并且产生新的行框</p>
<p>​      -行框内的元素遵循text-align和vertical-align</p>
<p>​     – height = line-height + vertical-align</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>定位、BFC、IFC</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固HTML第一天（基本标签属性）</title>
    <url>/2021/05/31/%E7%A8%B3%E5%9B%BAHTML%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A0%87%E7%AD%BE%E5%B1%9E%E6%80%A7%EF%BC%89/</url>
    <content><![CDATA[<h1 id="稳固-HTML-第一天"><a href="#稳固-HTML-第一天" class="headerlink" title="稳固 HTML 第一天"></a>稳固 HTML 第一天</h1><p>HTML 基本标签的学习</p>
<span id="more"></span>

<p>3.1 基本标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.div 没有具体含义 . 层 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2.hx:标题 1-6级 1级最大 6级最小 会自动加粗 有默认字号 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 3.p:表示段落 相当于一个回车 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 4.br：实现换行  单标签--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 5.hr：生成一条水平线 主要起一个装饰作用 单标签 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 6.a：用来设置超链接文本 实现连接跳转 </span></span><br><span class="line"><span class="comment">        属性：1.target：_blank 打开新窗口 </span></span><br><span class="line"><span class="comment">                       _self 当前窗口打开 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 7.img：用来加载外部图片、图像</span></span><br><span class="line"><span class="comment">         属性：src：设定加载图片、图像路径</span></span><br><span class="line"><span class="comment">              alt：当图片加载不出来时，将显示其内容</span></span><br><span class="line"><span class="comment">              title：鼠标移到图片上时的提示文字 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 8.span：作用于div一样 都是用来布局的 不同的是 div是单独占一行 span不会 属于行内布局 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 9.ul与ol：列表，前者是无序列表，后者为无序列表，他们的列表内容用的都是li标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.2 标签的属性</p>
<p>  标签属性：</p>
<p>​    –1.通常由属性名 = “属性值” 组成</p>
<p>​    –2.起一个附加信息的作用</p>
<p>​    –3.不是所有标签都有属性，如：br</p>
<p>3.3 文本格式化标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文本格式化标签：就是通过标签来美化文本外观 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1.b和strong：不会自动换行 都有加粗作用 但是strong还有强调作用。注：强调主要用于SEO时，便于提取关键字。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.i和em：不会自动换行 使文字倾斜，em具有强调作用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- pre：预格式化文本：块级标签 被pre标签包裹的文字 保留换行和空格及宽度，文字的字号会小一号。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--small和big：行内标签 分别让文字缩小或放大一号。注：big在HTML5中淘汰了，但没有删除，在开发中尽量还是不要使用淘汰的标签--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 浏览器支持的最小字号为12px，如果要显示比12px还小的文字效果，需要去另做处理 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--sub和sup：设置文字为上标和小标，用来调整文本正常显示的基线，且文字会自动小一号  --&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.4 实体转义符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实体转义的特点是&amp;开头 ;结尾 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    &amp;it;     &lt;</span></span><br><span class="line"><span class="comment">    &amp;gt;     &gt;</span></span><br><span class="line"><span class="comment">    &amp;amp;    &amp; </span></span><br><span class="line"><span class="comment">    &amp;nbsp;   空格</span></span><br><span class="line"><span class="comment">    &amp;copy;   版权©</span></span><br><span class="line"><span class="comment">    &amp;times;  乘号×</span></span><br><span class="line"><span class="comment">    &amp;divide; 除号÷</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.5 块级元素与行内元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 块级元素：相当于执行了display：block；操作</span></span><br><span class="line"><span class="comment">       独占一行</span></span><br><span class="line"><span class="comment">       宽度和高度是可控的，如果没有设置其高度，将默认铺满整行</span></span><br><span class="line"><span class="comment">       块级元素可以包含块级和行级标签   </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 行级元素：相当于执行了display：inline；操作</span></span><br><span class="line"><span class="comment">       不会独占一行 与相邻的行级元素 占同一行，直到行占满，会自动掉到下一行</span></span><br><span class="line"><span class="comment">       高度和宽度是不可控的</span></span><br><span class="line"><span class="comment">       其内只能包含行级元素</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.6  W3C规范</p>
<p>  W3C标准由结构、表现、形为三部分组成。</p>
<p>  1.标签嵌套规则，块级元素可以包含块级元素和内联元素 ，内联元素只能包含内联元素。</p>
<p>  2.块级元素不能放在p标签里。</p>
<p>  3.有几个特殊的块级标签不能包含块级元素,如:hx(1-6),p,dt。</p>
<p>  4.块级元素与块级元素并列,内嵌元素与内嵌元素并列</p>
<p>3.7  语义化标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 语义化标签 ：通俗点说，明白每个标签的用途</span></span><br><span class="line"><span class="comment">      1.更容易被搜索引擎收录</span></span><br><span class="line"><span class="comment">      2.更容易让屏幕阅读器读出网页内容</span></span><br><span class="line"><span class="comment">      3.能更好的体现主题页面</span></span><br><span class="line"><span class="comment">      4.兼容性更好，支持更多的网络设备。    </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1.a： 超链接本文 title强调</span></span><br><span class="line"><span class="comment">     2.q： 短文本引用 浏览器解析后 自动加引号</span></span><br><span class="line"><span class="comment">     3.address： 加入地址信息时 用它包裹</span></span><br><span class="line"><span class="comment">     4.caption：为表格添加标题和摘要  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固HTML第一天（表格）</title>
    <url>/2021/05/31/%E7%A8%B3%E5%9B%BAHTML%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E8%A1%A8%E6%A0%BC%EF%BC%89/</url>
    <content><![CDATA[<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h3 id="1-1绘制基本表格"><a href="#1-1绘制基本表格" class="headerlink" title="1.1绘制基本表格"></a>1.1绘制基本表格</h3><span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- table 表格 主要用于呈现格式化数据 表格是由行和列组成</span></span><br><span class="line"><span class="comment">         格式：</span></span><br><span class="line"><span class="comment">            &lt;table&gt;</span></span><br><span class="line"><span class="comment">                 &lt;tr&gt;</span></span><br><span class="line"><span class="comment">                     &lt;th&gt;&lt;/th&gt; 表头 主要对下面内容起说明作用 th的内容会自动加粗和居中显示</span></span><br><span class="line"><span class="comment">                     &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment">                     .......</span></span><br><span class="line"><span class="comment">                 &lt;/tr&gt;</span></span><br><span class="line"><span class="comment">                 .....</span></span><br><span class="line"><span class="comment">            &lt;/table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            table+tr*2&gt;td&#123;内容$&#125;*3</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        表格属性：</span></span><br><span class="line"><span class="comment">              1.boder 设置表格边框 默认单位是像素</span></span><br><span class="line"><span class="comment">              2.width 设置表格宽度 默认单位是像素</span></span><br><span class="line"><span class="comment">              3.align 设置表格对齐 left（默认）/center/right</span></span><br><span class="line"><span class="comment">              4.cellpadding 设置单元格间距 </span></span><br><span class="line"><span class="comment">              5.cellspacing 设置像素间隙</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;10&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>住址<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>007<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>岳阳<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>008<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>长沙<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.imagehub.cc/image/Y7ekU"><img src="https://s1.imagehub.cc/images/2021/05/31/01.png" alt="01.png"></a></p>
<h3 id="1-2-跨行-跨列"><a href="#1-2-跨行-跨列" class="headerlink" title="1.2 跨行/跨列"></a>1.2 跨行/跨列</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 跨行/跨列属性主要用来绘制复杂表格</span></span><br><span class="line"><span class="comment">        rowspan：跨行</span></span><br><span class="line"><span class="comment">        colspan：跨列</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">valign</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span>内容区01<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- valign:垂直对齐（top/middle/bottom） --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容区02<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>内容区03<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;内容区01&lt;/td&gt; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容区02<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;内容区03&lt;/td&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容区01<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容区02<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;td&gt;内容区03&lt;/td&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span>&gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>内容区01<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>内容区02<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容区02<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>内容区03<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span> <span class="attr">align</span>=<span class="string">&quot;right&quot;</span>&gt;</span>内容区01<span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.imagehub.cc/image/Y7Or4"><img src="https://s1.imagehub.cc/images/2021/05/31/02.png" alt="02.png"></a></p>
<h3 id="1-3-完整表单组成"><a href="#1-3-完整表单组成" class="headerlink" title="1.3 完整表单组成"></a>1.3 完整表单组成</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>完整表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 完整表格组成 ：caption（标题）、thead（表头）、tbody（表体）、tfoot（表尾）四部分组成 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;600&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生信息表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>家庭住址<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>001<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>TOM*<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>长沙<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>0000000<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>002<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>CAT<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>岳阳<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>11111111<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>003<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>Mouse<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>222222222<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>附注：*为优秀学生<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.imagehub.cc/image/Y71C5"><img src="https://s1.imagehub.cc/images/2021/05/31/03.png" alt="03.png"></a></p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>表格</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固HTML第一天（from与iframe）</title>
    <url>/2021/05/31/%E7%A8%B3%E5%9B%BAHTML%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88from%E4%B8%8Eiframe%EF%BC%89/</url>
    <content><![CDATA[<h1 id="From-元素及分类"><a href="#From-元素及分类" class="headerlink" title="From 元素及分类"></a>From 元素及分类</h1><p>from 表单标签是所有标签最核心的标签之一。它是用来实现前后端交互的一个重要标签 </p>
<p>​     常用属性 </p>
<p>​         name 表单名称</p>
<p>​         action 表单数据提交地方 通常是一个后台文件名或者网址 如果是# 则是提交到当前文件下</p>
<p>​         method 前端提交数据到后端的方法，主要有get和post，默认的是get ，get会带值，post不带 </p>
<span id="more"></span>

<h3 id="表单元素分为："><a href="#表单元素分为：" class="headerlink" title="表单元素分为："></a>表单元素分为：</h3><h2 id="input类"><a href="#input类" class="headerlink" title="input类"></a>input类</h2><p>​        主要用来完成输入、选择或发出指令。</p>
<p>​        type：text/password/radio/checkbox/file/button/image/submit/reset</p>
<h4 id="text-单行文本输入框-默认值"><a href="#text-单行文本输入框-默认值" class="headerlink" title="text:单行文本输入框 默认值"></a>text:单行文本输入框 默认值</h4><p>​          属性：placeholder（提示）/ name（命名）/minlength（最少输入字符个数）/maxlength(最多输入字符个数)</p>
<p>​             disabled（失效）/readonly（只读）/value (默认值)/pattern (正则)</p>
<p>​        password：密码框 属性与text一样</p>
<h4 id="rodio：单选框，通常属性是两项以上。"><a href="#rodio：单选框，通常属性是两项以上。" class="headerlink" title="rodio：单选框，通常属性是两项以上。"></a>rodio：单选框，通常属性是两项以上。</h4><p>​          属性：name（必须要有）/value/check（选中）/disabled（失效）/readonly（只读）</p>
<h4 id="checkbox：复选框，可以用来选择0项、1项或多项。"><a href="#checkbox：复选框，可以用来选择0项、1项或多项。" class="headerlink" title="checkbox：复选框，可以用来选择0项、1项或多项。"></a>checkbox：复选框，可以用来选择0项、1项或多项。</h4><p>​          属性：name（必须要有）/value/check（默认选中）/disabled（失效）/readonly（只读）</p>
<h4 id="file：文件上传按钮"><a href="#file：文件上传按钮" class="headerlink" title="file：文件上传按钮"></a>file：文件上传按钮</h4><h4 id="button：普通按钮，通常用它去调用脚本代码。"><a href="#button：普通按钮，通常用它去调用脚本代码。" class="headerlink" title="button：普通按钮，通常用它去调用脚本代码。"></a>button：普通按钮，通常用它去调用脚本代码。</h4><p>​          属性：value(按钮标题)/disabled（失效）</p>
<p>​        </p>
<h4 id="image：图片按钮，用法与button一样。有个特殊属性：src（用来加载提示图片，用它替换了value）"><a href="#image：图片按钮，用法与button一样。有个特殊属性：src（用来加载提示图片，用它替换了value）" class="headerlink" title="image：图片按钮，用法与button一样。有个特殊属性：src（用来加载提示图片，用它替换了value）"></a>image：图片按钮，用法与button一样。有个特殊属性：src（用来加载提示图片，用它替换了value）</h4><p>​          它也有提交功能，和submit功能一样</p>
<h4 id="submit：提交按钮，用来将表单数据提交到后台"><a href="#submit：提交按钮，用来将表单数据提交到后台" class="headerlink" title="submit：提交按钮，用来将表单数据提交到后台"></a>submit：提交按钮，用来将表单数据提交到后台</h4><p>​          属性：value(按钮标题)/disabled（失效）</p>
<h4 id="reset：重置按钮，将表单所有组件输入的内容全部清空，还原为初始状态"><a href="#reset：重置按钮，将表单所有组件输入的内容全部清空，还原为初始状态" class="headerlink" title="reset：重置按钮，将表单所有组件输入的内容全部清空，还原为初始状态"></a>reset：重置按钮，将表单所有组件输入的内容全部清空，还原为初始状态</h4><p>​          属性：value(按钮标题)/disabled（失效）</p>
<h2 id="textarea类"><a href="#textarea类" class="headerlink" title="textarea类"></a>textarea类</h2><p>​       文本域（也叫多行文本框），主要用来输入大批量内容</p>
<p>​       常用属性：name/id/clos(列数)/rows（行数）/placeholder/minlength/maxlength/required(必须输入)/value</p>
<h2 id="select类"><a href="#select类" class="headerlink" title="select类"></a>select类</h2><p>​       下拉列表框，默认用于单项选择，</p>
<p>​       属性：用option呈现每个选项 /multiple 表示可以多选 下拉列表框变成列表框 /size 最多显示行数</p>
<h2 id="button类"><a href="#button类" class="headerlink" title="button类"></a>button类</h2><p>​       写在from表单中的和input类里的作用一样 都是提交表单内的数据 ，写在外面的button 可以加入js逻辑来使用</p>
<h1 id="iframe-框架集"><a href="#iframe-框架集" class="headerlink" title="iframe 框架集"></a>iframe 框架集</h1><p>  iframe:框架集 用来将多个网页文件组合成一个文件</p>
<p>​    属性：</p>
<p>​      name:框架名</p>
<p>​      src：引入的外部html文件</p>
<p>​      scrolling：滚动条（yes/no/auto）</p>
<p>​      width：设置宽度</p>
<p>​      height：设置高度</p>
<p>​      frameboder：是否有边框（0/1）</p>
<p>​      marginheight：框架离顶部或底部的距离</p>
<p>​      marginwidth：框架离左边或右边的距离、</p>
<h5 id="注意：在实际开发中尽量少用iframe，因为它破坏了前进和后退功能，且不利于SEO"><a href="#注意：在实际开发中尽量少用iframe，因为它破坏了前进和后退功能，且不利于SEO" class="headerlink" title="注意：在实际开发中尽量少用iframe，因为它破坏了前进和后退功能，且不利于SEO"></a>注意：在实际开发中尽量少用iframe，因为它破坏了前进和后退功能，且不利于SEO</h5>]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>from</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固HTML第一天（标签的属性）</title>
    <url>/2021/05/31/%E7%A8%B3%E5%9B%BAHTML%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E6%A0%87%E7%AD%BE%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%89/</url>
    <content><![CDATA[<h2 id="标签的属性"><a href="#标签的属性" class="headerlink" title="标签的属性"></a>标签的属性</h2><p>  标签属性：</p>
<p>​    –1.通常由属性名 = “属性值” 组成</p>
<p>​    –2.起一个附加信息的作用</p>
<p>​    –3.不是所有标签都有属性，如：br</p>
<span id="more"></span>

<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文本格式化标签：就是通过标签来美化文本外观 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1.b和strong：不会自动换行 都有加粗作用 但是strong还有强调作用。注：强调主要用于SEO时，便于提取关键字。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.i和em：不会自动换行 使文字倾斜，em具有强调作用 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- pre：预格式化文本：块级标签 被pre标签包裹的文字 保留换行和空格及宽度，文字的字号会小一号。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--small和big：行内标签 分别让文字缩小或放大一号。注：big在HTML5中淘汰了，但没有删除，在开发中尽量还是不要使用淘汰的标签--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 浏览器支持的最小字号为12px，如果要显示比12px还小的文字效果，需要去另做处理 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--sub和sup：设置文字为上标和小标，用来调整文本正常显示的基线，且文字会自动小一号  --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实体转义符"><a href="#实体转义符" class="headerlink" title="实体转义符"></a>实体转义符</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实体转义的特点是&amp;开头 ;结尾 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    &amp;it;     &lt;</span></span><br><span class="line"><span class="comment">    &amp;gt;     &gt;</span></span><br><span class="line"><span class="comment">    &amp;amp;    &amp; </span></span><br><span class="line"><span class="comment">    &amp;nbsp;   空格</span></span><br><span class="line"><span class="comment">    &amp;copy;   版权©</span></span><br><span class="line"><span class="comment">    &amp;times;  乘号×</span></span><br><span class="line"><span class="comment">    &amp;divide; 除号÷</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="块级元素与行内元素"><a href="#块级元素与行内元素" class="headerlink" title="块级元素与行内元素"></a>块级元素与行内元素</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 块级元素：相当于执行了display：block；操作</span></span><br><span class="line"><span class="comment">       独占一行</span></span><br><span class="line"><span class="comment">       宽度和高度是可控的，如果没有设置其高度，将默认铺满整行</span></span><br><span class="line"><span class="comment">       块级元素可以包含块级和行级标签   </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 行级元素：相当于执行了display：inline；操作</span></span><br><span class="line"><span class="comment">       不会独占一行 与相邻的行级元素 占同一行，直到行占满，会自动掉到下一行</span></span><br><span class="line"><span class="comment">       高度和宽度是不可控的</span></span><br><span class="line"><span class="comment">       其内只能包含行级元素</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="W3C规范"><a href="#W3C规范" class="headerlink" title="W3C规范"></a>W3C规范</h2><p>  W3C标准由结构、表现、形为三部分组成。</p>
<p>  1.标签嵌套规则，块级元素可以包含块级元素和内联元素 ，内联元素只能包含内联元素。</p>
<p>  2.块级元素不能放在p标签里。</p>
<p>  3.有几个特殊的块级标签不能包含块级元素,如:hx(1-6),p,dt。</p>
<p>  4.块级元素与块级元素并列,内嵌元素与内嵌元素并列</p>
<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 语义化标签 ：通俗点说，明白每个标签的用途</span></span><br><span class="line"><span class="comment">      1.更容易被搜索引擎收录</span></span><br><span class="line"><span class="comment">      2.更容易让屏幕阅读器读出网页内容</span></span><br><span class="line"><span class="comment">      3.能更好的体现主题页面</span></span><br><span class="line"><span class="comment">      4.兼容性更好，支持更多的网络设备。    </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1.a： 超链接本文 title强调</span></span><br><span class="line"><span class="comment">     2.q： 短文本引用 浏览器解析后 自动加引号</span></span><br><span class="line"><span class="comment">     3.address： 加入地址信息时 用它包裹</span></span><br><span class="line"><span class="comment">     4.caption：为表格添加标题和摘要  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="通用标签属性"><a href="#通用标签属性" class="headerlink" title="通用标签属性"></a>通用标签属性</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 标签由标签名、标签属性、文本内容三部分组成（注意：单标签没有文本内容） --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 标签属性 是对一种标签的描述方式</span></span><br><span class="line"><span class="comment">       1.通用属性</span></span><br><span class="line"><span class="comment">       2.自有属性</span></span><br><span class="line"><span class="comment">       3.用户自定义属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通用属性：所有标签都具有的属性</span></span><br><span class="line"><span class="comment">        1.id 用来给标签取一个唯一的名称</span></span><br><span class="line"><span class="comment">        2.class 用来给标签取一个类名</span></span><br><span class="line"><span class="comment">        3.style 用来设置标签的行内样式</span></span><br><span class="line"><span class="comment">        4.title 当鼠标移到改标签，所显示的内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义属性 通常用来传值或图片的懒加载等方面</span></span><br><span class="line"><span class="comment">    格式：data-*  --&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>身体原因休息一天，明后两天刷面经</title>
    <url>/2021/06/04/%E8%BA%AB%E4%BD%93%E5%8E%9F%E5%9B%A0%E4%BC%91%E6%81%AF%E4%B8%80%E5%A4%A9%EF%BC%8C%E6%98%8E%E5%90%8E%E4%B8%A4%E5%A4%A9%E5%88%B7%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>稳固HTML第一天（页面初始化分析）</title>
    <url>/2021/05/31/%E7%A8%B3%E5%9B%BAHTML%E7%AC%AC%E4%B8%80%E5%A4%A9%EF%BC%88%E9%A1%B5%E9%9D%A2%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90%EF%BC%89/</url>
    <content><![CDATA[<h2 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h2><p>1.HTML  超文本标记语言。它是一种标志性语言，非编程语言，不能使用逻辑运算。通过标签将网上的文档格式进行统一，使分散的网络资源链接为一个逻辑整体。</p>
<p>1.1 超文本：是一种组织信息方式，通过超级链接将多种媒介关联起来。</p>
<p>1.2 标记： 标签，用&lt; &gt;包裹的具有一定含义的内容。</p>
<p>2.HTML页面初始化分析</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="comment">&lt;!--申明 下面的代码将由HTML5规范去解析--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="comment">&lt;!-- lang : language 语言 en：English 这里表达的是这个页面是英文页面 zh：为中文页面--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- 头部标签，主要用来完成一个网页的相关设置--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- meta 元，主要用于完成对应设置--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> <span class="comment">&lt;!--设置汉字编码--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="comment">&lt;!-- content内填写网页的搜索关键字--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="comment">&lt;!--content内填写网站的描述内容--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span> <span class="comment">&lt;!-- 这里是针对IE8 进行特别的渲染设置 避免IE8出错--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- viewport 显示器显示网页的大小</span></span><br><span class="line"><span class="comment">         content属性</span></span><br><span class="line"><span class="comment">           --width 和height 指令分别指定视区的逻辑宽度和高度。它们的值可以是以像素为单位的数字，也可以是一个特殊的标记符号</span></span><br><span class="line"><span class="comment">           --initial-scale用于设置Web页面的初始缩放比例。设为1.0则显示未经缩放的Web页面</span></span><br><span class="line"><span class="comment">           --maximum-scale和minimum-scale用于设置用户对于Web页面缩放比例的限制。值的范围为0.25~10.0之间</span></span><br><span class="line"><span class="comment">           --user-scalable指定用户是否可以缩放视区，即缩放Web页面的视图。值为yes时允许用户进行缩放，值为no时不允许缩放</span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment">        在scale为1的情况下，device-width = 设备的物理分辨率/devicePixelRatio</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="comment">&lt;!--标题 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;图片链接&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/图片格式&quot;</span>&gt;</span><span class="comment">&lt;!-- 设置网站小图标 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="comment">/* 书写页面样式 */</span></span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>&gt;</span><span class="comment">&lt;!-- 用来引入外部样式文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="comment">&lt;!-- 主题部分--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 书写脚本语言</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>页面</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue面试题</title>
    <url>/2021/06/07/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Vue面试题"><a href="#Vue面试题" class="headerlink" title="Vue面试题"></a>Vue面试题</h1><ol>
<li><p>Vue的核心是什么</p>
<p>Vue是一套构建用户界面的渐进式自底向上增量开发的MVVM框架，Vue的核心是只关注视图层</p>
<p>核心思想：</p>
<ul>
<li><p>核心驱动 ：视图的内容随着数据的改变而改变</p>
</li>
<li><p>组件化：可以增加代码的复用性，可维护性，可测试性，提高开发效率，方便重复使用，体现了高内聚低耦合</p>
<span id="more"></span></li>
</ul>
</li>
<li><p>简述你对Vue的理解</p>
<p>Vue是一套构建用户界面的渐进式自底向上增量开发的MVVM框架，Vue的核心是只关注视图层，是为了解决数据绑定问题，为了开发大型单页面应用和组件化，所以Vue的核心思想是数据驱动和组件化，还有它的MVVM思想，模型 视图 vm是v和m连接的桥梁，当模型数据层修改时，VM层会检测到，并通知视图层进行相应修改。</p>
</li>
<li><p>简述Vue单向数据流</p>
<ul>
<li><p>父级prop的更新会向下流动到子组件，每次父组件发生更新，子组件所有的prop都会刷新为最新的值</p>
</li>
<li><p>数据从父组件传递给子组件，只能单向绑定，子组件内部不能直接修改父组件传递过来的数据（Tips：可以使用data和computed解决）</p>
</li>
</ul>
</li>
<li><p>Vue常用的修饰符有哪些</p>
<ol>
<li>修饰符：<ul>
<li>.lazy 改变后触发，光标离开input输入框的时候值才会改变</li>
<li>.number 将输出字符串转换为number类型</li>
<li>.trim 自动过滤用户输入的首尾空格</li>
</ul>
</li>
<li>事件修饰符：<ul>
<li>.stop 阻止点击事件冒泡，相当于原生js中的event.stopPropagation（）</li>
<li>.prevent 防止执行预设的行为，相当于原生js中event.preventDefault()</li>
<li>.capture 添加事件侦听器时使用事件捕获模式，就是谁有该事件修饰符，就谁先触发</li>
<li>.self 只会触发自己范围内的事件，不包括子元素</li>
<li>.once 只执行一次</li>
</ul>
</li>
<li>键盘修饰符：<ul>
<li>.enter 回车键</li>
<li>.tab 指标建</li>
<li>.esc 返回键</li>
<li>.space 空格键</li>
<li>.up 向上键</li>
<li>.dowm 向下键</li>
<li>.left 向左键</li>
<li>.right 向右键</li>
</ul>
</li>
<li>系统修饰符<ul>
<li>.ctrl | .alt | .shift | .meta</li>
</ul>
</li>
</ol>
</li>
<li><p>v-text与 { { } } 与v-html的区别</p>
<ol>
<li><p> { { } } 将数据解析为纯文本，不能显示输出html，数据渲染得数据比较多的时候，可能会把大括号显示出来，俗称屏幕闪动</p>
</li>
<li><p>v-html 可以渲染出html</p>
</li>
<li><p>v-text 将数据解析为纯文本，不能输出真正的html，与花括号的区别是，在页面加载时不显示花括号</p>
</li>
<li><p>v-text的作用是操作网页元素中的纯文本内容。花括号是他的另一种写法</p>
</li>
<li><p>v-text与花括号写法等价，花括号叫模板插值，v-text叫指令。</p>
</li>
</ol>
</li>
<li><p>v-on可以绑定多个方法吗</p>
<p>可以，如果绑定多个事件，可以用键值对的形式，事件类型：事件名，且绑定多个事件的时候，直接用逗号分隔就行</p>
</li>
<li><p>Vue循环的key作用</p>
<p>key值的存在保证了唯一性，Vue在执行时，会对节点进行检查，如果没有key值，那么Vue检查到这里有dom节点，就会对内容清空并赋新值，如果有key值存在，那么会对新老节点进行对比，比较两者的key是否相同，进行调换位置或删除操作。</p>
</li>
<li><p>什么是计算属性</p>
<ul>
<li>计算属性是用来声明式的描述一个值依赖了其他的值，当它依赖的这个值发生改变时，就更新DOM</li>
<li>当在模板中把数据绑定到一个计算属性上时，vue会在它依赖的任何值导致该计算属性改变时更新DOM</li>
<li>每个计算属性都包括一个getter和setter，读取时触发getter，修改时触发setter</li>
</ul>
</li>
<li><p>Vue单页面的优缺点</p>
<ul>
<li><p>优点：前后端分离，用户体验好，快，内容改变不需要重新加载整个页面</p>
</li>
<li><p>缺点：不利于seo，初次加载时间耗时长，页面复杂度提高了，导航不可用</p>
</li>
</ul>
</li>
<li><p>Vuex是什么？怎么使用？在哪种场景下使用？</p>
<ol>
<li><p>Vuex是一个专门为vue.js应用程序开发的状态管理模式，通过创建一个集中的数据存储，方便程序中所有的组件进行访问，简单来说Vuex就是vue的状态管理工具</p>
</li>
<li><p>Vuex有五个属性 state getters mutations actions modules</p>
<ul>
<li>state 就是数据源存放地，对应一般vue对象的data，state里面存放的数据是响应式的，state数据发生改变，对应这个数据的组件也会发生改变，用this.$store.state.xxx调用</li>
<li>getters 相当于store的计算属性，主要是对state中的数据的过滤，用this.$store.getters.xxx调用</li>
<li>Mutations 处理数据逻辑的方法全部放在mutations中，当触发事件想改变state数据的时候使用mutations,用this.$store.commit调用，给这个方法添加一个参数，就是mutation的荷载（payload）</li>
<li>Actions 异步操作数据，但是是通过mutation来操作，用this.$store.dispatch来触发，actions也支持荷载</li>
<li>modules 模块化Vuex，可以让每个模块都有自己的五个属性</li>
</ul>
</li>
<li><p>使用场景：组件之间的状态，登录状态，加入购物车，音乐播放</p>
</li>
<li><p>Vuex使用流程</p>
<ol>
<li>下载vuex</li>
<li>在src下创建store以及index.js</li>
<li>引入vue和vuex，使用vuex，导出实例对象</li>
<li>在main.js中引入，在.vue文件中使用</li>
</ol>
</li>
</ol>
</li>
<li><p>Vue中路由跳转方式</p>
<p>Vue中路由跳转有两种，分别是声明式和编程式</p>
<ol>
<li><p>用js方式跳转叫编程式，this.&amp;router.push()</p>
</li>
<li><p>用router-link进行跳转的角声明式 ，router-view 路由出口，路由模板显示的位置</p>
</li>
</ol>
</li>
<li><p>路由中的name属性有什么作用？</p>
<p>在router-link中使用name导航到对应路由，使用name导航的同时，给字路由传递参数</p>
</li>
<li><p>Vue跨域的解决方式</p>
<ol>
<li><p>后台更改header</p>
</li>
<li><p>使用jq提供jsonp</p>
</li>
<li><p>用http-proxy-middleware（配置代理服务器的中间件）</p>
</li>
</ol>
</li>
<li><p>Vue的生命周期</p>
<p>Vue的声明周期就是vue实例创建到实例销毁的过程，期间会有8个钩子函数的调用</p>
<ol>
<li><p>beforeCreate 创建实例</p>
</li>
<li><p>created 创建完成</p>
</li>
<li><p>beforeMount 开始创建模板</p>
</li>
<li><p>mounted 创建完成</p>
</li>
<li><p>beforeUpdata 开始更新</p>
</li>
<li><p>updated 更新完成</p>
</li>
<li><p>beforeDestory 开始销毁</p>
</li>
<li><p>destoryed 销毁完成</p>
</li>
</ol>
</li>
<li><p>Vue生命周期的作用</p>
<p>给了用户在不同阶段添加自己代码的机会</p>
</li>
<li><p>DOM渲染在哪个生命周期阶段内完成</p>
<p>DOM渲染在mounted周期中就已经完成</p>
</li>
<li><p>Vue路由的实现</p>
<p>前端路由就是更新视图但是不请求页面，利用锚点完成切换，页面不会刷新，官方推荐用vue-router.js来引入路由模块</p>
<ol>
<li><p>定义路由组件</p>
</li>
<li><p>定义路由，使用conponent进行路由映射组件，用name导航到对应的路由</p>
</li>
<li><p>创建router实例，传入routes配置</p>
</li>
<li><p>创建和挂在根实例</p>
</li>
<li><p>容router-link设置路由跳转</p>
</li>
</ol>
</li>
<li><p>Vue路由模式hash和history</p>
<ul>
<li><p>Hash模式地址栏中有#，history没有，hostory模式下会刷新，出现404情况，需要后台配置</p>
</li>
<li><p>使用javascript来对loaction.hash进行赋值，改变URL的hash值</p>
</li>
<li><p>可以使用hashchange事件来监听hash值的变化</p>
</li>
<li><p>HTML5提供了History API来实现URl的变化。其中最主要的API有以下两个：history.pushState() 和 history.repalceState()。这两个API可以在不进行刷新的情况下，操作浏览器的历史记录，唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录</p>
</li>
</ul>
</li>
<li><p>Vue路由传参的两种方式，params和query的区别</p>
<p>动态路由也可以叫路由传参，就是根据不同的选择在同一个组件渲染不同的内容</p>
<ul>
<li><p>用法上：query用path引入，params用name引入，接受参数都是类似的，分别是this.$route.query.name 和 this.$route.params.name</p>
</li>
<li><p>url展示上：params类似于post，query类似于get，也就是安全问题，params传值相对安全点，刷新后，页面就不在了</p>
</li>
</ul>
</li>
<li><p>Vue数据绑定的几种方法</p>
<ol>
<li><p>单向绑定 双大括号  html内字符串绑定</p>
</li>
<li><p>v-bind绑定  html属性绑定</p>
</li>
<li><p>双向绑定 v-model</p>
</li>
<li><p>一次性绑定 v-once依赖于v-model</p>
</li>
</ol>
</li>
<li><p>Vue注册一个全局组件</p>
<p>Vue.componnet(“组件的名字”{</p>
<p>对象 </p>
<p>template </p>
<p>&lt; div&gt;组件的内容&lt; /div&gt;</p>
<p>})</p>
</li>
<li><p>Vue的路由钩子函数 / 路由守卫有哪些</p>
<ol>
<li><p>全局守卫：beforeEach（to，from，next）和afterEach（to，from）</p>
</li>
<li><p>路由独享守卫：beforeEnter</p>
</li>
<li><p>组件内的守卫</p>
<ul>
<li><p>beforeRouterEnter 路由进入</p>
</li>
<li><p>update 更新</p>
</li>
<li><p>leave 离开之前</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>Vue中的指令有哪些</p>
<ul>
<li><p>v-for：循环数组，对象，字符串，数字</p>
</li>
<li><p>v-on：绑定事件监听</p>
</li>
<li><p>v-bind：动态绑定一个或者多个属性</p>
</li>
<li><p>v-model：表单控件或者组件上创建双向绑定</p>
</li>
<li><p>v-if | v-else | v-else-if ：条件渲染</p>
</li>
<li><p>v-show：根据表达式真假，切换元素的display</p>
</li>
<li><p>v-html：更新元素的innerhtml</p>
</li>
<li><p>v-text：更新元素的textcontent</p>
</li>
<li><p>v-pre：跳过这个元素和子元素的编译过程</p>
</li>
<li><p>v-clock：这个指令保持在元素上直到关联实例结束编译 </p>
</li>
<li><p>v-once：只渲染一次</p>
</li>
</ul>
</li>
<li><p>Vue如何定义一个过滤器</p>
<p>过滤器本质就是一个有参数有返回值的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">   filters:&#123;</span><br><span class="line">      myCurrency:function(myInput)&#123;</span><br><span class="line">         return 处理后的数据</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用方法：&lt; h1&gt; { { 表达式 | 过滤器 } } &lt; /h1&gt;<br>过滤器高级用法：可以指定参数，告诉过滤器按照参数进行数据的过滤</p>
</li>
<li><p>对Vue中keep-alive的理解</p>
<ul>
<li><p>概念：leep-alive是vue的内置组件，当它动态包裹组建时，会缓存不到活动的组件实例，它自身不会渲染成一个DOM元素也不会出现在父组件链中</p>
</li>
<li><p>作用：在组件切换过程中，将状态保存在内存中，防止重复渲染DOM，减少加载时间以及性能消耗，提高用户体验</p>
</li>
<li><p>生命周期函数：Activated 在 keep-alive 组件激活时调用，deactivated在 keep-alive 组件停用时调用</p>
</li>
</ul>
</li>
<li><p>如何让组件中的css在当前组件生效</p>
<p>在styled中加上scoped</p>
</li>
<li><p>MVVM与MVC的区别</p>
<ul>
<li><p>MVC模型视图控制器，视图是可以直接访问模型的，所以视图里会包含模型信息，MVC关注的是模型不变，所以，在mvc中，模型不依赖视图，但是视图以来模型</p>
</li>
<li><p>MVVM模型 视图 和VM ，VM作为视图和模型的桥梁，当模型层数据改变，VM会检测到并通知视图层进行相应的修改</p>
</li>
</ul>
</li>
<li><p>Vue组件中的data为什么是函数</p>
<p>Data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立不会互相影响，如果是引用类型（对象），当多个组件共用一个数据源时，一处数据改变，所有的组件数据都会改变，所以要利用函数通过return返回对象的拷贝，（返回一个新数据），让每个实例都有自己的作用域，相互不影响</p>
</li>
<li><p>Vue双向绑定的原理</p>
<p>Vue双向绑定就是：数据变化更新视图，视图变化更新数据</p>
<p>Vue数据双向绑定是通过数据劫持和观察者模式来实现的</p>
<ul>
<li><p>数据劫持：object.defineproperty它的目的是：当给属性赋值的时候，程序可以感知到，就可以控制改变属性值</p>
</li>
<li><p>观察者模式：当属性发生改变的时候，使用该数据的地方也会发生改变</p>
</li>
</ul>
</li>
<li><p>Vue中组件怎么传值</p>
<ul>
<li>正向：父传子 ：父组件要把传递的数据绑定在属性上，发送，子组件通过props接收</li>
<li>逆向：子传父：子组件通过this.$emit（自定义事件名，要发送的数据），父组件设置一个监听事件来接受，然后拿到数据</li>
<li>兄弟：eventbus 中央事件总线</li>
<li>通过vuex</li>
</ul>
</li>
<li><p>槽口可以放什么内容？放在哪？什么作用？</p>
<ul>
<li><p>可以放任意内容，在子组件中使用，是为了将父组件中的子组件模板数据正常显示</p>
</li>
<li><p>具名插槽和匿名插槽，说白了就是在组件上的属性，可以在组件元素内使用</p>
</li>
<li><p>可以在父组件使用slot-scope从子组件获取数据</p>
</li>
</ul>
</li>
<li><p>Watch</p>
<p>Watch的作用是监控一歌值的变化，并调用因为变化需要执行的方法</p>
</li>
<li><p>计算属性与Watch的区别</p>
<p>区别就是计算属性的缓存功能，当无关数据数据改变时，不会重新计算，直接使用缓存中的值</p>
<ul>
<li><p>计算属性是用来 声明式的 描述 一个值 依赖了 其他的值，当所依赖的值后者变量发生变化时，计算属性也跟着改变</p>
</li>
<li><p>Watch监听是在data中定义的变量，当该变量发生变化时，会触发Watch中的方法</p>
</li>
</ul>
</li>
<li><p>Vue首屏加载慢的原因，怎么解决的，怎么解决白屏问题</p>
<p>首屏加载时间慢的原因：第一次加载页面有很多组件数据需要渲染</p>
<p>解决方法：</p>
<ol>
<li>路由懒加载</li>
<li>ui框架按需加载</li>
<li>gzip压缩</li>
</ol>
<p>解决白屏问题：</p>
<ol>
<li><p>使用v-text渲染数据</p>
</li>
<li><p>使用花括号语法渲染数据，但是同时使用v-cloak指令（用来保持在元素上直到关联实例结束的时候进行编译），v-cloak要放在什么位置呢？并不需要添加到每个标签，只要在el挂在的标签上添加就可以。</p>
</li>
</ol>
</li>
<li><p>Vuex中action如何提交给mutation的</p>
<p>Action函数接收一个与store实例具有相同方法和属性的context对象，可以调用 context.commit 提交一个 mutation，或者通过 context.state和 context.getters 获取 state 和 getters</p>
</li>
<li><p>Router与router区别</p>
<ol>
<li><p>router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router实例对象，VueRouter这个对象中是一个全局对象，他包含了所有路由和许多关键的对象和属性</p>
</li>
<li><p>router是一个跳转的路由对象，每一个路由都会有一个ruter对象，是一个局部对象，可以获取对应的 name,path,params,query 等</p>
</li>
</ol>
</li>
<li><p>vuex的Mutation特性是？</p>
<p>更改vuex store中修改状态的唯一办法就是提交mutation，可以在回调函数中修改store中的状态</p>
</li>
<li><p>vuex的actions特性是？</p>
<p>Action 类似于 mutation，不同的是 action 提交的是 mutation，不是直接变更状态，可以包含任意异步操作</p>
</li>
<li><p>Vuex中的Getter特性是？</p>
<p>Getter 可以对 state 进行计算操作，它就是 store 的计算属性，Getter 可以在多组件之间复用，如果一个状态只在一个组件内使用，可以不用 getters</p>
</li>
<li><p>Vuex的优势</p>
<ul>
<li><p>优点：解决了非父子组件的通信，减少了ajax请求此处，有些可以直接从state中获取</p>
</li>
<li><p>缺点：刷新浏览器，vuex中的state会重新变为初识状态，解决办法是vuex-along，得配合计算属性和sessionstorage（临时存储）来实现</p>
</li>
</ul>
</li>
<li><p>v-for与v-if优先级</p>
<p>首先不要把v-if和v-for用在同一个元素中，因为后者优先级更高，如果每一个都需要遍历整个数据，将会影响速度。而且如果v-if还为false的话，数据便渲染不出来了</p>
<p>可以将v-if写在包裹v-for数据的父级标签上，可以在v-for遍历之前就进行判定</p>
</li>
<li><p>proxy的理解</p>
<ul>
<li><p>vue的数据劫持有两个缺点</p>
<ol>
<li>无法监听通过索引修改数组的值的变化</li>
<li>无法监听object也就是对象的值的变化，所以vue2.x中才会有$set属性的存在</li>
</ol>
</li>
<li><p>proxy是es6推出的新api，可以弥补以上两个缺点，所以vue3.x版本用proxy替换了object.defineproperty</p>
</li>
</ul>
</li>
<li><p>vue3.0是如何变得更快的</p>
<ol>
<li><p>diff方法优先：vue2.x中的虚拟dom是进行全量对比</p>
</li>
<li><p>Vue3.0新增了静态标记（PatchFlag）</p>
</li>
<li><p>Vue2.x无论元素是否参与更新，每次都会重新创建，vue3.0对不参与更新的元素，只会被创建一次，之后会在每次渲染时候被不停的复用</p>
</li>
<li><p>cacheHandlers事件侦听器缓存，默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化，但是是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可</p>
</li>
</ol>
</li>
<li><p>v-if 和 v-show的区别，怎么选择使用？</p>
<p>最大的区别在于，对于不显示在页面上元素的处理</p>
<ul>
<li>v-if 不去渲染不显示的元素</li>
<li>v-show 是在不显示的元素里设置内联样式 display：none</li>
</ul>
<p>选择使用：</p>
<ul>
<li><p>如果一个元素在页面渲染的时候只用判定一次，后面不会再改变了，那就用v-if</p>
</li>
<li><p>如果要判定多次是否显示还是隐藏，就使用v-show</p>
</li>
</ul>
</li>
<li><p>父子组件生命周期执行顺序</p>
<ul>
<li><p>创建和渲染过程</p>
<ol>
<li>父组件创建</li>
<li>子组件创建</li>
<li>子组件渲染</li>
<li>父组件渲染</li>
</ol>
</li>
<li><p>数据更新</p>
<ol>
<li><p>父组件开始更新</p>
</li>
<li><p>子组件开始更新</p>
</li>
<li><p>子组件更新完毕</p>
</li>
<li><p>父组件更新完毕</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>nextTick</p>
<ul>
<li>当对一个数组添加元素，然后再进行dom查询时，会发现，查询后的数据是添加前的数据。是因为，Vue中的渲染是异步的，会在下一个Tick中渲染，所以会出现先查询元素，再添加元素的情况</li>
<li>解决办法：可以在methods内写this.$nectTick( () =&gt; { 要执行的语句 } )，这样就可以让这个要执行的语句，也在下一个Tick时执行，就不会产生上述情况</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>稳固JS第一天(上)</title>
    <url>/2021/06/09/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E4%B8%80%E5%A4%A9-%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="稳固JavaScript第一天"><a href="#稳固JavaScript第一天" class="headerlink" title="稳固JavaScript第一天"></a>稳固JavaScript第一天</h1><ol>
<li><h3 id="初识javascript"><a href="#初识javascript" class="headerlink" title="初识javascript"></a>初识javascript</h3><ol>
<li><p>javascript是什么？</p>
<ul>
<li><p>javascript是世界上最流行的语言之一，是一种运行在客户端的脚本语言（script是脚本的意思）</p>
</li>
<li><p>脚本语言：不需要编译，运行过程中由js解释器（js引擎）逐行来进行解析并执行</p>
</li>
<li><p>现在也可以基于Node.js技术进行服务端编程</p>
<span id="more"></span></li>
</ul>
</li>
<li><p>javascript的作用</p>
<ul>
<li><p>表单动态校验（密码强度检测）（JS产生最初的目的）</p>
</li>
<li><p>网页特效</p>
</li>
<li><p>服务端开发（Node.js）</p>
</li>
<li><p>桌面程序（Electron）</p>
</li>
<li><p>App（Cordova）</p>
</li>
<li><p>控制硬件-物联网（Ruff）</p>
</li>
<li><p>游戏开发（cocos2d-js）</p>
</li>
</ul>
</li>
<li><p>HTML / CSS / JS 的关系</p>
<ol>
<li><p>描述类语言</p>
<ul>
<li>HTML决定网页结构和内容，相当于人的身体</li>
<li>CSS决定网页呈现给用户的模样，相当于给人穿衣服、化妆</li>
</ul>
</li>
<li><p>编程类语言</p>
<ul>
<li>实现业务逻辑和页面控制（决定功能），相当于人的动作</li>
</ul>
</li>
</ol>
</li>
<li><p>浏览器执行JS简介</p>
<p>浏览器分为两部分 渲染引擎和JS引擎</p>
<ul>
<li>渲染引擎：用来解析HTML与CSS，俗称内核，比如chrom浏览器的bink，老版本的webkit</li>
<li>JS引擎：也称为JS解释器，用来读取网页中的javaScript代码，对其处理后运行，比如chrome浏览器的V8</li>
</ul>
<p>浏览器本身不会执行JS代码，而是通过内置JavaScript引擎来执行JS代码。JS引擎执行代码时逐行解释每一句源码（转换为机器语言），然后又计算机去执行，所以javascript归类为脚本语言，会逐行解释执行。</p>
</li>
<li><p>JS的组成</p>
<ul>
<li><p>ECMAScript ：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准</p>
</li>
<li><p>DOM：页面文档对象模型，对页面各个元素进行操作</p>
</li>
<li><p>BOM：浏览器对象模型，操控浏览器窗口</p>
</li>
</ul>
</li>
<li><p>JS初体验</p>
<p>JS三种书写位置</p>
<ol>
<li><p>行内式的js 直接写到元素内部</p>
<ul>
<li>可读性差，在html中编写大量JS代码时，不方便阅读；</li>
<li>引号易错，引号多层嵌套匹配时，非常容易弄混</li>
<li>特殊情况下使用</li>
</ul>
</li>
<li><p>内嵌式的js </p>
<ul>
<li>可以将多行js代码写到&lt; script &gt;标签中</li>
<li>内嵌JS是学习时常用的方式</li>
</ul>
</li>
<li><p>外部js </p>
<ul>
<li><p>利用HTML页面代码结构化，把大量JS代码独立到HTML页面之外，既美观，也方便文件级别的复用</p>
</li>
<li><p>引用外部JS文件的Script标签中间不可以写代码</p>
</li>
<li><p>适合JS代码量比较大的情况</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>JS注释</p>
<ol>
<li><p>单行注释 ctrl + /</p>
</li>
<li><p>多行注释 ctrl +alt + a(可以在VScode中修改快捷键方式)</p>
</li>
</ol>
</li>
<li><p>Javascript输入输出语句</p>
<ul>
<li><p>alert 浏览器弹出警示框</p>
</li>
<li><p>console.lig(msg) 浏览器控制台打印输出信息</p>
</li>
<li><p>prompt（info） 浏览器弹出输入框，用户可以输入</p>
</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ol>
<li><p>变量的概述</p>
<ol>
<li>什么是变量<ul>
<li>白话：变量就是一个装东西的盒子</li>
<li>通俗：变量是用于存放数据的容器。我们通过变量名获取数据，甚至数据可以修改</li>
</ul>
</li>
<li>变量在内存中的存储<ul>
<li>本质:变量是程序在内存中申请的一块用来存放数据的空间</li>
<li>类似于旅游住酒店，类名就是房间号，内存就是酒店，变量就是房间</li>
</ul>
</li>
</ol>
</li>
<li><p>变量的使用</p>
<p>变量在使用时分为两步：1.声明变量 2.赋值</p>
<ol>
<li><p>声明变量 var age; //声明一个名称为age的变量</p>
<ul>
<li>var是一个JS关键字，用来声明变量。使用该关键字声明变量后，计算机会自动分配变量的内存空间，不需要程序员管</li>
<li>age是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间</li>
</ul>
</li>
<li><p>赋值 age = 10；//给age这个变量赋值为10</p>
<ul>
<li>= 用来把右边的值，赋给左边的变量空间中 此处代表赋值的意思</li>
<li>变量值是程序员保存到变量空间里的值</li>
</ul>
</li>
<li><p>输出结果 console.log(age);</p>
</li>
<li><p>变量的初始化</p>
<p>var age = 18; //声明变量同时赋值为18</p>
<ul>
<li>声明一个变量并赋值，我们称之为变量的初始化</li>
</ul>
</li>
</ol>
</li>
<li><p>变量的语法扩展</p>
<ol>
<li><p>更新变量</p>
<ul>
<li>一个变量被重新赋值后，它原有的值就会被覆盖，变量值以最后一次值为准</li>
</ul>
</li>
<li><p>同时声明多个变量</p>
<ul>
<li>var age=18,address=’火影村’,sex=’2’;</li>
<li>同时声明多个变量时，只需要写一个var，多个变量名之间用英文逗号隔开</li>
</ul>
</li>
<li><p>声明变量的特殊情况</p>
<ol>
<li>只声明不赋值<ul>
<li>程序也不知道里面存的是啥，所以是Undefined 未定义的</li>
</ul>
</li>
<li>不声明 不赋值 直接使用<ul>
<li>报错：xxx is not defined</li>
</ul>
</li>
<li>不声明，直接赋值使用<ul>
<li>JS中可以使用，但是不建议，会变成全局变量</li>
</ul>
</li>
</ol>
</li>
<li><p>变量命名规范</p>
<ol>
<li><p>由字母、数字、下划线、($)美元符号 组成</p>
</li>
<li><p>严格区分大小写</p>
</li>
<li><p>不能以数字开头</p>
</li>
<li><p>不能是关键字、保留字</p>
<ul>
<li>有特殊意义的就是关键字</li>
<li>保留字指在高级语言中已经定义过的字，使用者不能再将这些字作为变量名使用</li>
</ul>
</li>
<li><p>变量名必须有意义</p>
</li>
<li><p>遵守驼峰命名法</p>
</li>
<li><p>推荐翻译网站：有道，爱词霸</p>
<p>（Tips：我们尽量不要直接使用name 作为变量名）</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>数据类型</p>
<ol>
<li><p>数据类型的简介</p>
<ol>
<li><p>为什么需要数据类型</p>
<ul>
<li>在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需的大小，充分利用存储空间，于是定义了不用的数据类型</li>
<li>简单来说，数据类型就是数据的类别型号</li>
</ul>
</li>
<li><p>变量的数据类型</p>
<ul>
<li>变量时用来存储值的所在处，他们有名字和数据类型。变量的数据类型决定了如何将这些代表值的位，存储到计算机的内存中。javascript是一个弱语言或者说动态语言。<strong>这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</strong></li>
<li>javascript拥有动态语言，变量的数据类型是可以变化的</li>
</ul>
</li>
<li><p>数据类型的分类</p>
<p>JS把数据类型分为两类</p>
<ul>
<li>简单（基本）数据类型：Number，String，Boolean，Undefined，Null</li>
<li>复杂（引用）数据类型：Object</li>
</ul>
</li>
</ol>
</li>
<li><p>简单数据类型</p>
<ol>
<li><p>Number 数字型，包含整型值和浮点型值 | 默认值为0</p>
<ul>
<li>八进制 0~7 程序里数字前面为0，就代表是8进制</li>
<li>16进制 0<del>9、a</del>f ，在程序里数字前面是0x，就代表16进制</li>
<li>数字型范围 （5e-324 ~ 1.7976931348623157e+308）</li>
<li>数字型三个特殊值<ol>
<li>Infinity 代表无穷大，大于任何一个数字</li>
<li>-Infinity 代表无穷小，小于任何一个数字</li>
<li>NaN Not a number， 代表一个非数值</li>
</ol>
</li>
<li>isNaN（）这个方法判断非数字，如果是数字，返回false，不是数字则返回true</li>
</ul>
</li>
<li><p>Boolean 布尔值类型 如true、false等价于1、0 | 默认值为false</p>
</li>
<li><p>String 字符串类型 ，注意，JS里字符串都带引号 | 默认值为“”</p>
<ol>
<li><p>外单内双，外双内单</p>
</li>
<li><p>字符串转义符 转义符都是 \ 开头的</p>
<ul>
<li> \ n ：换行符，n是newline的意思</li>
<li> \ \ ：斜杠 \ </li>
<li> \ ‘ ：单引号</li>
<li> \ ‘’ ：双引号</li>
<li> \ t ：tab缩进</li>
<li> \ b：空格，b是blank的意思</li>
</ul>
</li>
<li><p>字符串长度 </p>
<p>字符串是由若干字符组成的，字符的数量就是字符串的长度，通过length属性，可以获取整个字符串长度</p>
</li>
<li><p>字符串的拼接</p>
<ul>
<li>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</li>
<li>拼接前会把字符串相加的任何类型转换为字符串，再拼接成一个新的字符串</li>
</ul>
</li>
</ol>
</li>
<li><p>Undefined 默认值为Undefined</p>
<ul>
<li>Undefined和数字相加 ，最后的结果是NaN</li>
</ul>
</li>
<li><p>Null 默认值为Null</p>
<ul>
<li>Null和数字相加，最后结果是相加的那个数字</li>
</ul>
</li>
</ol>
</li>
<li><p>获取变量数据类型</p>
<ol>
<li>获取检测变量的数据类型 typeof<ul>
<li>prompt 取过来的值是字符型的</li>
</ul>
</li>
<li>字面量<ul>
<li>字面量是在源代码中一个固定值的表示方法，通俗来说，就是通过字面量如何表达这个值</li>
</ul>
</li>
</ol>
</li>
<li><p>数据类型转化</p>
<ol>
<li><p>什么是数据类型转换</p>
<p>使用表单、prompt获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换为另一种数据类型</p>
</li>
<li><p>我们通常会实现三种方式的转换</p>
<ul>
<li><p>转换为字符串类型</p>
<ol>
<li>toString（）</li>
<li>String（）强制转换</li>
<li>加号拼接字符串 num + ‘  ‘ （隐式转换）</li>
</ol>
</li>
<li><p>转换为数字类型</p>
<ol>
<li>parselnt(string)函数：将string类型转换为整数数值型</li>
<li>parseFloat(string)函数：将string类型转换为浮点数值型</li>
<li>Number()强制转换函数：将string类型转换为数值型</li>
<li>js隐式转换（ - | * | / ）：利用算数运算隐式转为数值型</li>
</ol>
</li>
<li><p>转换为布尔型</p>
<ul>
<li><p>Boolean()函数：其他类型转换为布尔值</p>
<ul>
<li><p>代表空、否定的值都会被转换为false，如 ‘ ‘ 、0、NaN、null、undefined</p>
</li>
<li><p>其余值都会被转换为true</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>扩展</p>
<ol>
<li>解释性语言和编译型语言<ul>
<li>解释型语言：首先把菜做好，才能上桌吃饭（需要编译成中间代码，再执行）</li>
<li>编译型语言：好比涮火锅，边吃边涮，同时进行</li>
</ul>
</li>
<li>标识符、关键字、保留字<ol>
<li>标识符<ul>
<li>标识符：就是只开发人员为变量、属性、函数、参数取的名字</li>
</ul>
</li>
<li>关键字<ul>
<li>指JS本身已经使用了的字，不能再用他们充当变量名和方法名</li>
</ul>
</li>
<li>保留字<ul>
<li>实际上就是预留的关键字，意思是现在虽然还不是关键字，但是未来可能成为关键字，同样不能使用他们当变量名或方法名</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>稳固JS第一天(下)</title>
    <url>/2021/06/09/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E4%B8%80%E5%A4%A9-%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="Javascript第一天（下）"><a href="#Javascript第一天（下）" class="headerlink" title="Javascript第一天（下）"></a>Javascript第一天（下）</h1><ol>
<li><h3 id="Javascript运算符"><a href="#Javascript运算符" class="headerlink" title="Javascript运算符"></a>Javascript运算符</h3><ul>
<li><p>运算符也被称为操作符，用于实现赋值、比较、执行算数运算符等功能的符号</p>
</li>
<li><p>常用的运算符有</p>
<span id="more"></span>

<ul>
<li><p>算数运算符</p>
<ol>
<li>算术运算符概述<ul>
<li>算术运算使用的符号，用于执行两个变量或值的算术运算</li>
<li>（+ | - | * | / | %取余）</li>
</ul>
</li>
<li>浮点数的精度问题<ul>
<li>浮点数的最高精度是17位小数，但在进行算术计算时，其精确度远远不如整数，所以不要判断两个浮点数是否相等</li>
</ul>
</li>
<li>算术运算符也是有优先级的</li>
<li>表达式和返回值<ul>
<li>表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合，简单理解就是由数字、运算符、变量等组成的式子</li>
<li>表达式最终都会有一个结果，我们称其为返回值</li>
</ul>
</li>
</ol>
</li>
<li><p>递增和递减运算符</p>
<ul>
<li><p>如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（–）运算符来完成</p>
</li>
<li><p>++或– 放前面我们称为前置递增（递减）运算符，放在后面时，我们称为后置递增（递减）运算符</p>
</li>
<li><p>前置递增运算符</p>
<ul>
<li>++num前置递增，先自加，后返回值</li>
</ul>
</li>
<li><p>后置递增运算符</p>
<ul>
<li><p>num++ 后置递增，先返回原值，后自加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//结果打印为10</span></span><br><span class="line"><span class="built_in">console</span>.log(age++ +<span class="number">10</span>);<span class="comment">//结果打印为20</span></span><br><span class="line"><span class="built_in">console</span>.log(age);<span class="comment">//结果打印为11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> f = e++ + ++e;<span class="comment">//e++ 导致e=11，所以++e为12</span></span><br><span class="line"><span class="built_in">console</span>.log(f);<span class="comment">//打印结果为22</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>比较运算符</p>
<ul>
<li>比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值，作为比较运算的结果</li>
<li>有 &lt; | &gt; | &gt;= |&lt;= | ==（默认转化数据类型） | != | ===（全等，要求值和数据类型都一致） 、!==，</li>
<li>单等赋值，双等判断，三等全等</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<ul>
<li>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值，后面开发中经常用于多个条件的判断</li>
<li>有 &amp;&amp; 逻辑与 、 || 逻辑或 、！逻辑非</li>
<li>逻辑与：有一侧为false，结果就为false</li>
<li>逻辑或：有一侧为true，结果就为true</li>
<li>逻辑非：取反符</li>
<li>短路运算（逻辑中断）<ul>
<li>原理：当有多个表达式（值）时，左边的表达式可以确定结果时，就不再继续运算后面表达式的值</li>
<li>逻辑与<ul>
<li>语法：表达式1 &amp;&amp; 表达式2</li>
<li>如果第一个表达式为真，则返回表达式2</li>
<li>如果第一个表达式为假，则返回表达式1</li>
</ul>
</li>
<li>逻辑或<ul>
<li>语法：表达式1 || 表达式2</li>
<li>如果第一个表达式为真，则返回表达式1</li>
<li>如果第一个表达式为假，则返回表达式2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>赋值运算符</p>
<ul>
<li>有 = | +=、-= （加/减 之后再赋值）| *=、/=、%= （乘、除、取余之后再赋值）</li>
</ul>
</li>
<li><p>运算符优先级</p>
<ul>
<li><p>小括号 &gt; 一元运算符（==、++、！等） &gt; 算数运算符（先乘除后加减） &gt; 关系运算符（大于小于啥的）&gt; 相等运算符 &gt; 逻辑运算符 (先&amp;&amp;后||) &gt; 赋值运算符（=）&gt; 逗号运算符(,)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span> &gt;= <span class="number">6</span> || <span class="string">&#x27;人&#x27;</span>!=<span class="string">&#x27;阿凡达&#x27;</span>&amp;&amp;!(<span class="number">12</span>*<span class="number">2</span>==<span class="number">144</span>)&amp;&amp;<span class="literal">true</span>);<span class="comment">//返回值为true</span></span><br><span class="line"><span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>==num/<span class="number">2</span>&amp;&amp;(<span class="number">2</span>+<span class="number">2</span>*num).toString()===<span class="string">&#x27;22&#x27;</span>);<span class="comment">//返回值为true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="javascript流程控制-分支"><a href="#javascript流程控制-分支" class="headerlink" title="javascript流程控制-分支"></a>javascript流程控制-分支</h3><p>流程控制就是来控制我们的代码按照什么结构顺序来执行</p>
<p>主要有三种结构，分别是 顺序结构、分支结构和循环结构</p>
<ol>
<li><p>顺序流程控制</p>
<ul>
<li>顺序结构时程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的</li>
</ul>
</li>
<li><p>分支流程控制if语句</p>
<ul>
<li><p>由上到下执行代码的过程中，根据不同的条件，执行不同的路径，从而得到不同的结果</p>
</li>
<li><p>JS语言提供了两种分支结构语句</p>
<ul>
<li><p>if语句 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行思路：如果if里面的条件表达式为真，则执行大括号里的语句，如果为假，则执行if语句后面的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//双分支语句</span></span><br><span class="line">        <span class="keyword">var</span> age = prompt(<span class="string">&#x27;你多少岁啦？&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(age&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">            alert(<span class="string">&quot;语句1：你可以进入网吧&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;语句2：你不准进入网吧，因为你没满18岁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//满足条件执行语句1，不满足条件执行语句2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多分支语句</span></span><br><span class="line">        <span class="keyword">var</span> year = prompt(<span class="string">&#x27;输入年份&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            alert(<span class="string">&#x27;这是闰年&#x27;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            alert(<span class="string">&quot;这是闰年&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;这是平年&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//else if 里面的条件是可以任意多个的且else if 中间有个空格</span></span><br></pre></td></tr></table></figure></li>
<li><p>switch语句</p>
</li>
<li><p>switch语句和if else if 语句的区别</p>
<ol>
<li>一般情况下，他们两个语句可以相互替换</li>
<li>switch…case语句通常处理case为比较确定值的情况，而if else if语句更加灵活，常用于范围判断</li>
<li>switch语句进行条件判断后直接执行到程序的条件语句，效率更高，而if else if语句有几种条件，就得多判断几次</li>
<li>分支较少的时候，if else if语句的执行效率比switch语句要高</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三元表达式</p>
<ul>
<li>有三元运算符组成的式子我们称为三元表达式</li>
<li>语法结构：条件表达式 ？表达式1 ： 表达式2 </li>
<li>如果表达式为真，则执行表达式1，反之执行表达式2</li>
</ul>
</li>
<li><p>分支流程控制swich语句</p>
<ul>
<li><p>swich语句也是多分支语句，它用于基于不同条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用switch</p>
</li>
<li><p>语句结构与实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        执行语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行最后的语句;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行思路：利用我们表达式的值 和case后面的value选项值相匹配，如果匹配上，就执行该case里的语句，如果都没匹配上，那么执行default里面的语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1.我们在开发里面，表达式我们经常写成变量</span></span><br><span class="line"><span class="comment">2.我们num的值和case里面的值相匹配的时候是全等，必须是数值和类型一致才可以</span></span><br><span class="line"><span class="comment">3.break 如果当前的case里面没有break，则不会退出swich是继续执行下一个case</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例，查询水果</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> fruit = prompt(<span class="string">&#x27;请输入您想要的水果&#x27;</span>);</span><br><span class="line">        <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;苹果&#x27;</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;价格是5元一个&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;梨子&quot;</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;价格是6元一斤&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;桃子&#x27;</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;价格是15元一斤&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;这里没有您想要的水果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>稳固JS第二天</title>
    <url>/2021/06/10/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="稳固Javascript第二天"><a href="#稳固Javascript第二天" class="headerlink" title="稳固Javascript第二天"></a>稳固Javascript第二天</h1><ol>
<li><h3 id="Javascript流程控制-循环"><a href="#Javascript流程控制-循环" class="headerlink" title="Javascript流程控制-循环"></a>Javascript流程控制-循环</h3><ol>
<li><p>循环</p>
<p>在实际问题中，有许多具有规律性的重复操作，因此在程序中要完成这类操作就需要重复执行某些语句</p>
<p>在JS中，主要有三种类型的循环语句：</p>
<ul>
<li><p>for循环</p>
</li>
<li><p>while循环</p>
</li>
<li><p>do….while循环</p>
<span id="more"></span></li>
</ul>
</li>
<li><p>for循环</p>
<p>在程序中，一组被重复执行的语句被称之为循环体，能否继续重复执行，取决于循环的终止条件。由循环体及循环的终止条件组成的语句，被称之为循环语句</p>
<ul>
<li>for 重复执行某些代码，通常跟计数有关系</li>
<li>初始化变量：就是用var 声明一个普通变量，通常作为计数器使用</li>
<li>条件表达式：就是用来决定每一次循环是否继续进行，就是终止的条件</li>
<li>操作表达式：是每次循环最后执行的代码，经常用于我们计数器变量进行更新</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(初始化变量; 条件表达式; 操作表达式)&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for循环的执行过程</span></span><br><span class="line"><span class="comment">1.首先执行里面的计数器变量 var i=1. 但是这句话在for循环里只执行一次</span></span><br><span class="line"><span class="comment">2.去 i&lt;100 来判断是否满足条件，如果满足条件 就去执行循环体，不满足则退出循环</span></span><br><span class="line"><span class="comment">3.最后去执行i++ 如果写的是++1，结果也是一样，因为这个东西用;隔开了，是单独执行的</span></span><br><span class="line"><span class="comment">-------第一轮结束-------</span></span><br><span class="line"><span class="comment">4.接着执行i&lt;100，满足条件执行循环体，不满足退出循环</span></span><br><span class="line"><span class="comment">5.执行i++</span></span><br><span class="line"><span class="comment">..................知道i&gt;=100，不满足i&lt;100的条件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例1：求1-100之间所有整数的累加和</span></span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line"><span class="comment">//案例2：要求用户输入班级人数，之后一次输入每个学生的成绩，最后打印出该班级总的成绩以及平均成绩</span></span><br><span class="line">        <span class="keyword">var</span> people = prompt(<span class="string">&quot;请输入你们班级的人数&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> grade = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> all=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=people;i++)&#123;</span><br><span class="line">            grade = prompt(<span class="string">&#x27;请输入第&#x27;</span>+i+<span class="string">&quot;个同学的成绩&quot;</span>);</span><br><span class="line">            all += grade*<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;班级总成绩为:&quot;</span>+all+<span class="string">&quot;班级平均成绩为&quot;</span>+all/people);</span><br></pre></td></tr></table></figure></li>
<li><p>双重for循环</p>
<ul>
<li>很多情况下，单层for循环并不能，满足我们的要求，有时可以通过循环嵌套来实现</li>
<li>循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for循环，这样的for循环语句我们称之为双重for循环</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">for</span>(外层的初始化变量;外层的条件表达式;外层的操作表达式)&#123;</span><br><span class="line">    <span class="keyword">for</span>(里层的初始化变量;里层的条件表达式;里层的操作表达式)&#123;</span><br><span class="line">        <span class="comment">//执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.我们可以把里面的循环看成是外层循环的语句</span></span><br><span class="line"><span class="comment">2.外层的循环循环一次，里面的循环执行全部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印五行五列星星</span></span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">            str +=<span class="string">&#x27;※&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str +=<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">//打印倒三角</span></span><br><span class="line">        <span class="keyword">var</span> str=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">                str +=<span class="string">&quot;※&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            str +=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">//打印9x9乘法表</span></span><br><span class="line">        num = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                num += <span class="string">&quot; &quot;</span>+j+<span class="string">&quot;x&quot;</span>+i+<span class="string">&#x27;=&#x27;</span>+(i*j)+<span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            num +=<span class="string">&quot;\n&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure></li>
<li><p>while循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//while 语法结构  当.....的时候</span></span><br><span class="line"><span class="keyword">while</span>(条件表达式)&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行思路 当条件表达式结果为true，则执行循环体 否则退出循环</span></span><br><span class="line"><span class="comment">//里面应该也要有操作表达式 完成计数器的更新 防止死循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例：弹出一个提示框：你爱我吗 如果输入我爱你，就结束，否则一直询问</span></span><br><span class="line">    <span class="keyword">var</span> love =<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(love!==<span class="string">&quot;我爱你&quot;</span>)&#123;</span><br><span class="line">        love = prompt(<span class="string">&quot;你爱我吗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(<span class="string">&quot;我也爱你&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>do while循环</p>
<ul>
<li><p>do …while 其实是while语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环</p>
</li>
<li><p>1</p>
</li>
<li><p>1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法结构</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//执行思路：与while不同的地方在鱼，这个先执行一次循环体，再判断条件</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>continue break </p>
<ol>
<li><p>continue关键字</p>
<ul>
<li>用于立即跳出本次循环，继续下一次循环(本次循环体中有continue之后的代码就会少执行一次)</li>
</ul>
</li>
<li><p>break关键字</p>
<ul>
<li>用于立即跳出整个循环</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="javascript数组"><a href="#javascript数组" class="headerlink" title="javascript数组"></a>javascript数组</h3><ol>
<li><p>数组的概念</p>
<ol>
<li><p>什么是数组？</p>
<p>数组是指一组数据的集合，其中每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式</p>
</li>
</ol>
</li>
<li><p>创建数组</p>
<ol>
<li><p>数组的创建方式</p>
<p>数组有两种创建方式</p>
<ul>
<li><p>利用new创建数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//创建一个空的数组</span></span><br></pre></td></tr></table></figure></li>
<li><p>利用数组字面量创建数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []; <span class="comment">//创建了一个空的数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;hxr&quot;</span>,<span class="literal">true</span>];</span><br><span class="line"><span class="comment">//数组里面的数据一定用逗号分隔，数组里面的数据，我们称为数组元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.数组的字面量是方括号[]</span></span><br><span class="line"><span class="comment">2.声明数组并赋值称为数组的初始化</span></span><br><span class="line"><span class="comment">3.这种字面量方法也是我们以后最多使用的方法</span></span><br><span class="line"><span class="comment">4.数组中可以存放任意类型的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>获取数组中的元素</p>
<p>数组的索引</p>
<ul>
<li>索引（下标）：用来访问数组元素的序号（数组下标从0开始）</li>
<li>数组可以通过索引来访问（得到）、设置、修改对应的数组元素，我们可以通过“数组名[索引]”的形式来获取数组中的元素</li>
<li>没有这个数组元素，会输出undefined</li>
</ul>
</li>
<li><p>遍历数组</p>
<p>遍历：就是把数组中的每个元素从头到尾都访问一次（类似点名）</p>
<ol>
<li><p>数组的长度</p>
<ul>
<li><p>使用”数组名.length”可以访问数组元素的数量（数组长度），动态检测数组的元素个数</p>
</li>
<li><p>数组长度是元素个数，不要和索引号弄混淆</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(sum);</span><br><span class="line">        <span class="built_in">console</span>.log(sum/arr.length);</span><br><span class="line"><span class="comment">//示例2：求数组[2,6,1,77,52,57,7]的最大值</span></span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">77</span>,<span class="number">52</span>,<span class="number">57</span>,<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">var</span> num = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&lt;arr[i])&#123;</span><br><span class="line">                num = arr[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(num);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>数组中新增元素</p>
<ol>
<li><p>通过修改length长度来新增数组元素</p>
<ul>
<li>可以通过修改length长度来实现数组扩容的目的</li>
<li>length属性是可以读写的</li>
</ul>
</li>
<li><p>通过修改数组索引新增数组元素</p>
<ul>
<li><p>可以通过修改数组索引的方式追加数组元素</p>
</li>
<li><p>不要直接给数组名赋值，这样会覆盖之前的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：新建一个数组，里面存放十个整数</span></span><br><span class="line">        <span class="keyword">var</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            arr[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>数字案例</p>
<ol>
<li><p>删除指定数组元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例1：将数组[.........]中的0去掉后，形成一个不包含0的新数组        var arr = [2,0,6,1,77,0,52,0,25,7];        var arr2=[];        for (var i = 0;i &lt;arr.length;i++) &#123;            if(arr[i]!==0)&#123;                arr2[arr2.length]=arr[i]            &#125;        &#125;        console.log(arr2);</span></span><br></pre></td></tr></table></figure></li>
<li><p>翻转数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例2：将数组[.......]的内容反过来存放        var arr = [2,0,6,1,77];        var arr2=[];        for (var i =arr.length-1;i&gt;=0;i--) &#123;                arr2[arr2.length]=arr[i]        &#125;        console.log(arr2);</span></span><br></pre></td></tr></table></figure></li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>稳固JS第三天</title>
    <url>/2021/06/11/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="Javascript第三天"><a href="#Javascript第三天" class="headerlink" title="Javascript第三天"></a>Javascript第三天</h1><ol>
<li><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ul>
<li><p>冒泡排序是一种简单的排序算法。它重复的走访过要排序的列表，一次比较两个元素，如果他们的顺序错误，就把他们换过来，走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列顶端</p>
<span id="more"></span></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视频标准写法</span></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">var</span> arr2=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                arr2[<span class="number">0</span>]=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=arr2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//看视频前自己的写法</span></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">var</span> arr2=[];</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j =arr.length-i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[i+num])&#123;</span><br><span class="line">                arr2[<span class="number">0</span>]=arr[i];</span><br><span class="line">                arr[i]=arr[i+num];</span><br><span class="line">                arr[i+num]=arr2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            num++; </span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="comment">//分析，虽然是实现了，但是代码过于复杂，也比标准的多设了一个变量，对i与j的使用合理性还是需要磨练</span></span><br></pre></td></tr></table></figure></li>
<li><h3 id="javascript函数"><a href="#javascript函数" class="headerlink" title="javascript函数"></a>javascript函数</h3><ol>
<li><p>函数的概念</p>
<ul>
<li>在JS里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量的重复使用。虽然for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用JS中的函数</li>
<li>函数：就是封装了一段可被重复调用执行的代码块，通过此代码块可以实现大量代码的重复使用</li>
</ul>
</li>
<li><p>函数的使用</p>
<ul>
<li><p>函数的使用分为两步：声明函数和调用函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名 （）</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.function声明函数的关键字 全部小写</span></span><br><span class="line"><span class="comment">2.函数是做某些事情，函数名一般是动词</span></span><br><span class="line"><span class="comment">3.函数不调用，自己不会执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.调用函数</span></span><br><span class="line">函数名();</span><br><span class="line"><span class="comment">//调用函数的时候千万不要忘记加小括号</span></span><br></pre></td></tr></table></figure></li>
<li><p>函数的封装</p>
<ul>
<li>函数的封装就是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</li>
</ul>
</li>
</ul>
</li>
<li><p>函数的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以利用函数的参数实现函数重复不同的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形参<span class="number">1</span>，形参<span class="number">2.</span>...</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">函数名(实参<span class="number">1</span>,实参<span class="number">2.</span>...);</span><br><span class="line"><span class="comment">//函数的参数可以有，也可以没有，个数不限</span></span><br></pre></td></tr></table></figure>



<ul>
<li>形参：形式上的参数，函数定义的时候，传递的参数，当前并不知道是什么</li>
<li>实参：实际上的参数，函数调用的时候传递的参数，实参是传递给形参的</li>
<li>参数的作用：在函数内部某些值不能固定的时候，我们可以通过参数在调用函数时传递不同的值进去</li>
<li>函数形参和实参个数不匹配的问题<ul>
<li>如果实参个数和形参个数一致，则正常输出结果</li>
<li>如果实参个数多于形参个数，会取到形参的个数</li>
<li>如果实参个数小于形参的个数，个数不够的形参结果就是undefined</li>
<li>在Javascript中，形参的默认值是undefined</li>
</ul>
</li>
</ul>
</li>
<li><p>函数的返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数的返回值格式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> 需要返回的结果;</span><br><span class="line">&#125;</span><br><span class="line">函数名();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.我们的函数只是实现某种功能，最终的结果需要返回给函数的调用者</span></span><br><span class="line"><span class="comment">2.只要函数遇到return，就把后面的结果 返回给函数的调用者 类似于函数名（）=return 后面的结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//代码小demo</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num1&gt;num2)&#123;</span><br><span class="line">                <span class="keyword">return</span> num1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(getNum(<span class="number">99</span>,<span class="number">100</span>));</span><br><span class="line"><span class="comment">//案例：求一段数组中的最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getArr</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> arrMax=arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arrMax&lt;arr[i])&#123;</span><br><span class="line">                    arrMax=arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arrMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> re = getArr([<span class="number">5</span>,<span class="number">2</span>,<span class="number">99</span>,<span class="number">101</span>,<span class="number">67</span>,<span class="number">77</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(re);</span><br></pre></td></tr></table></figure>



<ul>
<li>return终止函数<ul>
<li>return 之后的代码不被执行</li>
<li>return 只能返回一个值</li>
</ul>
</li>
<li>函数没有return返回undefined</li>
</ul>
</li>
<li><p>arguments的使用</p>
<ul>
<li><p>当不确定有多少个参数传递的时候，可以用arguments来获取，在Javascript中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arguments的使用 只有函数才有arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//我们可以按照数组的方式遍历arguments</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//案例：利用函数，求任意个数的最大值</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getArr</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> arrMax=<span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arrMax&lt;<span class="built_in">arguments</span>[i])&#123;</span><br><span class="line">                    arrMax=<span class="built_in">arguments</span>[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arrMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> re = getArr(<span class="number">5</span>,<span class="number">2</span>,<span class="number">99</span>,<span class="number">101</span>,<span class="number">67</span>,<span class="number">77</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(re);</span><br></pre></td></tr></table></figure></li>
<li><p>arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p>
<ul>
<li>具有length属性</li>
<li>按索引方式存储数据</li>
<li>不具有数组的push，pop等方法</li>
</ul>
</li>
</ul>
</li>
<li><p>函数案例</p>
<ul>
<li>函数可以调用另外一个函数<ul>
<li>因为每个函数都是独立的代码块，用于完成特殊任务，因此经常会用到函数相互调用的情况</li>
</ul>
</li>
</ul>
</li>
<li><p>函数的两种声明方式</p>
<ul>
<li><p>利用函数关键字自定义函数</p>
</li>
<li><p>函数表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数表达式 （匿名函数）</span></span><br><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br><span class="line"><span class="comment">//fun 是变量名，不是函数名</span></span><br><span class="line"><span class="comment">//函数表达式声明方式跟声明变量差不多，只不过变量里存的是值，而函数表达式里面存的是函数</span></span><br><span class="line"><span class="comment">//函数表达式也可以进行传递参数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><h3 id="javascript作用域"><a href="#javascript作用域" class="headerlink" title="javascript作用域"></a>javascript作用域</h3><ol>
<li><p>作用域</p>
<ul>
<li>通常来说，一段程序代码中所用到的名字（变量）并不总是有效和可用的，而限定这个名字可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少名字冲突</li>
<li>js作用域（ES6）之前：全局作用域和局部作用域<ul>
<li>全局作用域：整个script标签或者是单独的js文件</li>
<li>局部作用域：函数内部就是局部作用域，这个代码的名字只在函数的内部起效果</li>
</ul>
</li>
</ul>
</li>
<li><p>变量的作用域</p>
<p>在javascript中，根据作用域的不同，变量可以分为两种</p>
<ul>
<li>全局变量：在全局作用域下的变量<ul>
<li>如果在函数内部没有声明，直接赋值的变量，也属于全局变量</li>
</ul>
</li>
<li>局部变量：在局部作用域下的变量，只能在函数内部使用<ul>
<li>函数的形参也可以看成局部变量</li>
</ul>
</li>
</ul>
<p>从执行效率来看全局变量和局部变量</p>
<ul>
<li>全局变量：只有浏览器关闭的时候才会销毁，比较占内存资源</li>
<li>局部变量：当我们程序执行完毕就会销毁，比较节约内存资源</li>
</ul>
<p>JS在ES6的时候新增的块级作用域</p>
</li>
<li><p>作用域链</p>
<ul>
<li>根据在内部函数可以访问外部函数变量的这个机制，用链式查找决定哪些数据能被内部访问，就称为作用域 （就近原则）</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="javascript预解析"><a href="#javascript预解析" class="headerlink" title="javascript预解析"></a>javascript预解析</h3><ol>
<li><p>预解析</p>
<ul>
<li>javaScript代码是由浏览器中的javaScript解析器来执行的，javascript解析器在运行javascript代码的时候分为两步：预解析和代码执行<ul>
<li>预解析：JS引擎会把js里面所有的var 还有function提升到当前作用域的最前面</li>
<li>代码执行：按照代码书写的顺序从下往下执行</li>
</ul>
</li>
<li>预解析分为变量预解析（变量提升）和函数预解析（函数提升）<ul>
<li>变量提升：就是把所有的变量声明提升到当前作用域最前面，且不提升赋值</li>
<li>函数提升：就是把所有的函数声明提升到当前作用域最前面，且不调用函数</li>
<li>所以，函数表达式（匿名函数），调用必须写在函数表达式的下面，因为他是var的变量名，是变量提升</li>
</ul>
</li>
</ul>
</li>
<li><p>预解析案例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1();</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = b = c=<span class="number">9</span> <span class="comment">//这里可以当成var a=9,然后b=9,c=9会没有声明直接提升到全局</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>今天教室要清考场没时间学啦，这几天弄微信小程序作业去了，10000字哇！~~~</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>请假一天</title>
    <url>/2021/06/12/%E8%AF%B7%E5%81%87%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<p>要写微信小程序课程设计啦，一万字，所以今天一天就交给它啦~~~</p>
]]></content>
  </entry>
  <entry>
    <title>稳固JS第四天</title>
    <url>/2021/06/13/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E5%9B%9B%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="稳固JS第四天"><a href="#稳固JS第四天" class="headerlink" title="稳固JS第四天"></a>稳固JS第四天</h1><ol>
<li><h3 id="javascript对象"><a href="#javascript对象" class="headerlink" title="javascript对象"></a>javascript对象</h3><ol>
<li><p>对象 </p>
<ul>
<li><p>现实生活中：万物皆可对象，对象是<strong>一个具体的事物</strong>，看得见摸得着的实物，一个数据库，一张网页、一个与远程服务器的连接也可以是“对象”</p>
</li>
<li><p>在javascript中，对象是一组无序的<strong>相关属性</strong>和<strong>方法</strong>的集合，所有事物都是对象，例如字符串、数值、数组、函数等</p>
<ul>
<li>属性：事物的特征，在对象中用属性来表示（常用名词）</li>
<li>方法：事物的行为，在对象中用方法来表示（常用动词）</li>
</ul>
</li>
<li><p>为什么需要对象？</p>
<ul>
<li><p>JS中对象表达结构更清晰，更强大。</p>
<span id="more"></span></li>
</ul>
</li>
</ul>
</li>
<li><p>创建对象的三种方法</p>
<ol>
<li><p>利用字面量创建对象</p>
<ul>
<li><p>对象的字面量：就是花括号里面包含了表达这个具体事物（对象）的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用对象字面量创建对象&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;<span class="comment">//创建了一个空的对象</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">uname</span>:<span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="string">&quot;男&quot;</span>，</span><br><span class="line">    <span class="attr">sayHi</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.里面的属性，我们采取键值对的形式。 键：属性名 值：属性值</span></span><br><span class="line"><span class="comment">2.多个属性或者方法中间用逗号隔开的</span></span><br><span class="line"><span class="comment">3.方法冒号后面跟的是一个匿名函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.uname);</span><br><span class="line"><span class="built_in">console</span>.log(obj2[<span class="string">&#x27;age&#x27;</span>]);</span><br><span class="line">obj.sayHi();</span><br><span class="line"><span class="comment">//使用对象</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.1 调用对象的属性，我们采取 对象名.属性名</span></span><br><span class="line"><span class="comment">1.2 对象名[&#x27;属性名&#x27;]</span></span><br><span class="line"><span class="comment">2.1 调用对象的方法sayHi: 对象名.方法名</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>变量、属性、函数、方法的区别</p>
<ul>
<li>变量和属性的相同点<ul>
<li>他们都是用来存储数据的</li>
</ul>
</li>
<li>变量和属性的不同点<ul>
<li>变量：单独声明并赋值，使用的时候直接写变量名，单独存在</li>
<li>属性：在对象里面的不需要声明，使用的时候必须是对象.属性</li>
</ul>
</li>
<li>函数和方法的相同点<ul>
<li>都是实现某种功能</li>
</ul>
</li>
<li>函数和方法的不同点<ul>
<li>函数：是单独声明的，并且调用的函数名（）单独存在</li>
<li>方法：在对象里面，调用的时候 对象.方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>利用new Object创建对象</p>
<ul>
<li><p>跟new Array（）原理一致</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用 new Object创建对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&quot;张三丰&quot;</span>;</span><br><span class="line">obj.age = <span class="number">18</span>;</span><br><span class="line">obj.sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">obj.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.我们是利用等号 = 赋值的方法，添加对象的属性和方法</span></span><br><span class="line"><span class="comment">2.每个属性和方法之间用分号结束</span></span><br><span class="line"><span class="comment">3.调用属性和之前的字面量创建一致</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">        obj.name=<span class="string">&quot;鸣人&quot;</span>;</span><br><span class="line">        obj.age = <span class="number">19</span>;</span><br><span class="line">        obj.sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">        obj.skill = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;螺旋丸&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">console</span>.log(obj);</span><br><span class="line">        obj.skill();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>利用构造函数创建对象</p>
<ul>
<li><p>我们为什么需要使用构造函数</p>
<ul>
<li>因为我们前面的两种创建对象的方式，一次只能创建一个对象</li>
<li>所以我们可以利用函数的方法，重复这些相同的代码，我们就把这个函数称为构造函数</li>
<li>又因为这个函数不一样，里面封装的不是普通代码，而是对象，所以构造函数就是把我们对象里面一些相同的属性和方法抽象出来封装到函数里面</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用构造函数创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.属性 = 值;</span><br><span class="line">    <span class="built_in">this</span>.方法 = <span class="function"><span class="keyword">function</span> （）</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> 构造函数名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例一：创建四大天王</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">uname,age,sex</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name=uname;</span><br><span class="line">   <span class="built_in">this</span>.age = age;</span><br><span class="line">   <span class="built_in">this</span>.sex = sex;</span><br><span class="line">   <span class="built_in">this</span>.sing = <span class="function"><span class="keyword">function</span>(<span class="params">sang</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(sang)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">&quot;刘德华&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">ldh.sing(<span class="string">&quot;冰雨&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.构造函数名首字母要大写</span></span><br><span class="line"><span class="comment">2.我们构造函数不需要return 就可以返回结果（new关键字来返回）</span></span><br><span class="line"><span class="comment">3.我们调用构造函数 必须使用new</span></span><br><span class="line"><span class="comment">4.我们只要new Star（）调用函数，就创建一个对象</span></span><br><span class="line"><span class="comment">5.我们的属性和方法前面必须添加this</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//案例2：</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Hero</span> (<span class="params">name,type,blood</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.type = type;</span><br><span class="line">            <span class="built_in">this</span>.bolld = blood;</span><br><span class="line">            <span class="built_in">this</span>.attack = <span class="function"><span class="keyword">function</span> (<span class="params">attack</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;攻击方式:&quot;</span>+attack);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> lianpo = <span class="keyword">new</span> Hero(<span class="string">&quot;廉颇&quot;</span>,<span class="string">&#x27;力量型&#x27;</span>,<span class="string">&quot;500血量&quot;</span>);</span><br><span class="line">        lianpo.attack(<span class="string">&quot;近战&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(lianpo);</span><br><span class="line">        <span class="keyword">var</span> houyi = <span class="keyword">new</span> Hero(<span class="string">&quot;后羿&quot;</span>,<span class="string">&#x27;射手型&#x27;</span>,<span class="string">&quot;100血量&quot;</span>);</span><br><span class="line">        houyi.attack(<span class="string">&quot;远程&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(houyi);</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数和对象</p>
<ul>
<li>构造函数：如Star()；泛指某一大类，类似于java语言里的类</li>
<li>对象：如new Star（）；特指某一个</li>
<li>我们利用构造函数创建对象的过程，也称为对象的实例化</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>new关键字</p>
<ul>
<li><p>new关键字的执行过程</p>
<ul>
<li><p>new 构造函数 可以在内存中创建一个空的对象</p>
</li>
<li><p>this 就会指向刚才创建的空对象</p>
</li>
<li><p>执行构造函数里面的代码，给这个空对象添加属性的方法</p>
</li>
<li><p>返回这个对象（所以构造函数里不需要return）</p>
<p>（Tips：New和构造函数在一起之后，生了个宝宝，这个宝宝必须是亲身的this指向，孩子长大开始学习知识，往脑子里塞了一堆知识，然后工作赚钱，回报父母）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>遍历对象属性</p>
<ul>
<li><p>for…in语句用于对数组或者对象的属性进行循环操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构：</span></span><br><span class="line"><span class="keyword">for</span>(变量 <span class="keyword">in</span> 对象)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(变量);<span class="comment">// 变量输出的到是属性名</span></span><br><span class="line">    <span class="built_in">console</span>.log(对象[变量]);<span class="comment">//得到的是属性值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们使用 for in里面的变量，我们喜欢用k或者key</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><h3 id="Javascript的内置对象"><a href="#Javascript的内置对象" class="headerlink" title="Javascript的内置对象"></a>Javascript的内置对象</h3><ol>
<li><p>内置对象</p>
<ul>
<li>javascript中对象分为三种：自定义对象、内置对象、浏览器对象<ul>
<li>前两个对象是JS基础内容，属于ECMAScript，第三个浏览器对象属于JS独有</li>
</ul>
</li>
<li>内置对象就是值JS语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法）</li>
<li>内置对象的最大优点就是能帮助我们开发</li>
</ul>
</li>
<li><p>查文档</p>
<ul>
<li>MDN<ul>
<li>学习一个内置对象的使用，只要学会其常用成员的使用即可，我们都可以通过查文档学习。</li>
<li>Mozilla开发者网络（MDN）提供了有关开放网络技术的信息，包括HTML、CSS、万维网以及HTML5应用的API</li>
</ul>
</li>
<li>如何学习对象中的方法<ul>
<li>查阅该方法的功能</li>
<li>查看里面参数的意义和类型</li>
<li>查看返回值的意义和类型</li>
<li>通过demo进行测试</li>
</ul>
</li>
</ul>
</li>
<li><p>Math对象</p>
<ul>
<li><p>Math对象不是一个构造函数，所以我们不需要用new来调用，而是直接使用里面的属性和方法即可</p>
</li>
<li><p>调用Math方法时，有无法转换成数字的值，便会返回NaN，如果没放任何值，就会返回-Infinity</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：封装自己的数学对象</span></span><br><span class="line">        <span class="keyword">var</span> obj =&#123;</span><br><span class="line">            <span class="attr">PI</span>:<span class="number">3.1415926535</span>,</span><br><span class="line">            <span class="attr">max</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> max = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">1</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">arguments</span>[i]&gt;max)&#123;</span><br><span class="line">                        max = <span class="built_in">arguments</span>[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> max;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">min</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> min = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">1</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">arguments</span>[i]&lt;min)&#123;</span><br><span class="line">                        min = <span class="built_in">arguments</span>[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">console</span>.log(obj.PI);</span><br><span class="line">        <span class="built_in">console</span>.log(obj.max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">8</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(obj.min(<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>三个取整方法</p>
<ul>
<li>Math.floor( )：向下取整</li>
<li>Math.ceil( ):向上取整</li>
<li>Math.round( ):四舍五入 里面的 .5 比较特殊，只往大了取</li>
</ul>
</li>
<li><p>随机数方法 random( )</p>
<ul>
<li><p>随机数取值范围为[0,1)</p>
</li>
<li><p>这个方法里面不跟参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：猜数字1-50,且只有十次机会</span></span><br><span class="line">        <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">50</span> - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> add=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> num1=prompt(<span class="string">&#x27;你猜猜我是哪个数呀&#x27;</span>);</span><br><span class="line">        <span class="keyword">while</span>(num!=num1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;num1)&#123;</span><br><span class="line">            num1=prompt(<span class="string">&#x27;你猜小啦，继续猜呀,还剩&#x27;</span>+(<span class="number">10</span>-add)+<span class="string">&quot;次机会哦&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&lt;num1)&#123;</span><br><span class="line">            num1=prompt(<span class="string">&#x27;你猜大啦，继续猜呀，还剩&#x27;</span>+(<span class="number">10</span>-add)+<span class="string">&quot;次机会哦&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        add++;</span><br><span class="line">        <span class="keyword">if</span>(add&gt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(add&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">        alert(<span class="string">&quot;你猜对啦！就是&quot;</span>+num+<span class="string">&quot;,恭喜你！&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;你的机会用完啦&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>日期对象</p>
<ul>
<li><p>Date（）日期对象，是一个构造函数，必须要new来调用创建我们的日期对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用Date 如果没有参数，返回当前系统的当前时间</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">//参数常用的写法：数字型 2021,6,13 或者是字符串型 &quot;2021-6-13 8:8:8&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>日期格式化(年月日)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化日期 年月日</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date.getFullYear());</span><br><span class="line"><span class="built_in">console</span>.log(date.getMonth()+<span class="number">1</span>);<span class="comment">//返回的月份会小一个月，记得+1</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getDay());<span class="comment">//返回的周日是0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//案例：</span></span><br><span class="line">        <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> year = date.getFullYear();</span><br><span class="line">        <span class="keyword">var</span> month = date.getMonth()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> dates = date.getDate();</span><br><span class="line">        <span class="keyword">var</span> day = date.getDay();</span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="string">&#x27;星期日&#x27;</span>,<span class="string">&#x27;星期一&#x27;</span>,<span class="string">&#x27;星期二&#x27;</span>,<span class="string">&#x27;星期三&#x27;</span>,<span class="string">&#x27;星期四&#x27;</span>,<span class="string">&#x27;星期五&#x27;</span>,<span class="string">&#x27;星期六&#x27;</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;今天是&quot;</span>+year+<span class="string">&quot;年&quot;</span>+month+<span class="string">&quot;月&quot;</span>+dates+<span class="string">&quot;日 &quot;</span>+arr[day]);</span><br></pre></td></tr></table></figure></li>
<li><p>日期格式化(时分秒)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式化日期 时分秒</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">getTimer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> h = date.getHours();</span><br><span class="line">        h = h&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + h : h;</span><br><span class="line">        <span class="keyword">var</span> m = date.getMinutes();</span><br><span class="line">        m = m&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + m : m;</span><br><span class="line">        <span class="keyword">var</span> s = date.getSeconds();</span><br><span class="line">        s = s&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + s : s;</span><br><span class="line">        <span class="keyword">return</span> h+<span class="string">&#x27;:&#x27;</span>+m+<span class="string">&#x27;:&#x27;</span>+s;</span><br><span class="line">        &#125;;</span><br><span class="line">        alert(getTimer());</span><br></pre></td></tr></table></figure></li>
<li><p>获取日期的总毫秒形式(时间戳)</p>
<ul>
<li>不是当前时间的毫秒数，而是距离1970年1月1日过了多少毫秒</li>
<li>通过ValueOf( )  | getTime() 获取</li>
<li>简单的写法(最常用的写法)：var date = +new Date;</li>
<li>H5新增方法：console.log( Date.now( ) );</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：倒计时</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">核心算法：</span></span><br><span class="line"><span class="comment">1.输入的时间减去现在的时间，就是剩余时间</span></span><br><span class="line"><span class="comment">2.用时间戳来做</span></span><br><span class="line"><span class="comment">3.把剩余的时间总的毫秒数转换为天、时、分、秒</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">var</span> hours = prompt(<span class="string">&quot;截止时间，时&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> min = prompt(<span class="string">&quot;截止时间，分&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> miao = prompt(<span class="string">&quot;截止时间,秒&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// var bf=0;</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">countTime</span> (<span class="params">time</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">var</span> inputTime = +<span class="keyword">new</span> <span class="built_in">Date</span>(time);</span><br><span class="line">            <span class="keyword">var</span> timer = (inputTime - nowTime)/<span class="number">1000</span>;<span class="comment">//化为秒</span></span><br><span class="line">            <span class="comment">// bf = timer;</span></span><br><span class="line">            <span class="keyword">var</span> d = <span class="built_in">parseInt</span>(timer/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">            d = d&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + d : d;</span><br><span class="line">            <span class="keyword">var</span> h = <span class="built_in">parseInt</span>(timer/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>);</span><br><span class="line">            h = h&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + h : h;</span><br><span class="line">            <span class="keyword">var</span> m = <span class="built_in">parseInt</span>(timer/<span class="number">60</span>%<span class="number">60</span>);</span><br><span class="line">            m = m&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + m : m;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="built_in">parseInt</span>(timer%<span class="number">60</span>);</span><br><span class="line">            s = s&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + s : s;</span><br><span class="line">            <span class="keyword">return</span> d+<span class="string">&quot;天&quot;</span>+h+<span class="string">&quot;时&quot;</span>+m+<span class="string">&quot;分&quot;</span>+s+<span class="string">&quot;秒&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// while(true)&#123;</span></span><br><span class="line">        <span class="built_in">console</span>.log(countTime(<span class="string">&#x27;2021-6-13 &#x27;</span>+hours+<span class="string">&#x27;:&#x27;</span>+min+<span class="string">&#x27;:&#x27;</span>+miao));</span><br><span class="line">        <span class="comment">// if(bf==0)&#123;</span></span><br><span class="line">        <span class="comment">//     break;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组对象</p>
<ul>
<li><p>创建数组对象的两种方式</p>
<ul>
<li>字面量方式</li>
<li>new Array（）</li>
</ul>
</li>
<li><p>检测是否为数组的两种函数</p>
<ul>
<li>instanceof 运算符，他可以用来检测是否为数组</li>
<li>Array.isArray(参数);H5新增的方法，IE9+以上支持</li>
</ul>
</li>
<li><p>添加删除数组元素的方法</p>
<ul>
<li>push(参数1…..)：末尾添加一个或多个元素，会修改原数组，返回值是他的新长度</li>
<li>pop()：删除数组最后一个元素，把数组长度减1，无参数，会修改原数组，返回值是它删除的元素的值</li>
<li>unshift(参数1….)：向数组的开头添加一个或更多元素，会修改原数组，返回值是它的新长度</li>
<li>shift()：删除数组的第一个元素，数组长度减1，无参数，会修改原数组，返回值是第一个元素的值</li>
</ul>
</li>
<li><p>数组排序</p>
<ul>
<li><p>reverse（）：颠倒数组中元素的顺序，无参数，会改变原数组，返回新数组</p>
</li>
<li><p>sort（）：对数组的元素进行排序，该方法会改变原数组，返回新数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用sort（）发现，如果不是个位数，就会出错，所以要在里面定义一个函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;<span class="comment">//按照升序的顺序进行排列</span></span><br><span class="line">    <span class="keyword">return</span> b-a;<span class="comment">//按照降序的顺序进行排列</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>数组索引方法</p>
<ul>
<li>indexOf（）：数组中查找给定元素的第一个索引，如果存在返回索引号，如果不存在则返回-1<ul>
<li>只返回第一个满足条件的索引号</li>
</ul>
</li>
<li>lastindexOf（）：在数组中的最后一个索引，如果存在返回索引号，如果不存在，则返回-1<ul>
<li>只返回第一个满足条件的索引号</li>
</ul>
</li>
</ul>
</li>
<li><p>数组去重（重点案例）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">核心算法：遍历旧数组，拿着就数组遍历出来的元素去查询新数组，没有这个元素就添加到新数组里面去，有的话，就会返回-1，就不管它</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> newArr=[];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newArr.indexOf(arr[i])==-<span class="number">1</span>)&#123;</span><br><span class="line">                    newArr.push(arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newArr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> arr = [<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">        <span class="built_in">console</span>.log(unique(arr));</span><br></pre></td></tr></table></figure></li>
<li><p>数组转换为字符串</p>
<ul>
<li>toString（）：把数组转换为字符串，逗号分隔每一项，返回值是一个字符串</li>
<li>join（’分隔符’）：方法用于把数组中的所有元素转换为一个字符串，返回值是一个字符串，默认分隔符为逗号</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串对象</p>
<ul>
<li><p>基本包装类型：就是把简单数据类型包装成了复杂数据类型，中间又发生了什么呢？</p>
<ul>
<li>var 临时变量 = new String(‘简单数据名’)</li>
<li>再把临时变量的值 赋给简单数据名</li>
<li>再讲临时变量销毁，临时变量=null；</li>
</ul>
</li>
<li><p>字符串不可变性</p>
<ul>
<li>指的是，里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中开辟了一个新的内存空间，放后面赋的值</li>
</ul>
</li>
<li><p>根据字符串返回位置</p>
<ul>
<li><p>字符串所有方法都不会修改字符串本身，操作完成会返回一个新的字符串</p>
</li>
<li><p>indexOf（”要查找的字符” , 开始的位置）：返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index的索引号</p>
</li>
<li><p>lastIndexOf（）：从后往前找，只找第一个匹配的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：返回字符的位置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.核心算法：先查找一个o出现的位置</span></span><br><span class="line"><span class="comment">2.然后，只要indexOf返回的结果不是-1，就继续往后查找</span></span><br><span class="line"><span class="comment">3.因为indexOf只能查找第一个，所以后面的查找，利用第一个查到的索引+1，从而继续查找</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">var</span> sy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> sy1 = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">zifu</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(zifu.indexOf(<span class="string">&#x27;o&#x27;</span>,sy)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                sy = zifu.indexOf(<span class="string">&#x27;o&#x27;</span>,sy)+<span class="number">1</span>;</span><br><span class="line">                sy1 +=(sy-<span class="number">1</span>).toString()+<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="string">&#x27;出现了&#x27;</span>+num+<span class="string">&#x27;次，分别在&#x27;</span>+sy1+<span class="string">&quot;个位置&quot;</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(search(<span class="string">&#x27;abcoefoxyozzopp&#x27;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>根据位置返回字符（重点）</p>
<ul>
<li>charAt（index）：返回指定位置的字符（index：字符串的索引号）</li>
<li>charCodeAt（index）：获取指定位置处字符的ASCLL码，目的：判断用户按下了哪个键</li>
<li>str[index]：获取指定位置处字符，IE8+支持</li>
</ul>
</li>
<li><p>案例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断一个字符串，出现最多次数的字符，并统计其次数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">核心算法：</span></span><br><span class="line"><span class="comment">1.利用charAt（）遍历这个字符串</span></span><br><span class="line"><span class="comment">2.把每个字符都存储给对象，如果对象没有该属性，就为1，存在了就+1</span></span><br><span class="line"><span class="comment">3.遍历数组，得到最大值和该字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> text = <span class="string">&quot;abcoefoxyozzopp&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> ch = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;text.length;i++)&#123;</span><br><span class="line">           <span class="keyword">var</span> text1= text.charAt(i);</span><br><span class="line">           <span class="keyword">if</span>(obj[text1])&#123;</span><br><span class="line">               obj[text1] += <span class="number">1</span> ; </span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               obj[text1]=<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(obj);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obj[k]&gt;max)&#123;</span><br><span class="line">                max = obj[k];</span><br><span class="line">                ch = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(max,ch);</span><br></pre></td></tr></table></figure></li>
<li><p>字符串操作方法（重点）</p>
<ul>
<li>concat(str1,str2,str3…)：concat（）方法用于连接两个或多个字符串。</li>
<li>substr(start,length)：从start位置开始（索引号），length取的个数</li>
<li>slice（start，end）：从start开始，截取到end，end取不到（两个都是索引号）</li>
<li>substring（start，end）：从start位置开始，截取到end位置，end取不到，基本和slice相同，但是不接受负值</li>
</ul>
</li>
<li><p>替换字符串</p>
<ul>
<li>replace（’被替换的字符’,’替换为的字符’），找不到返回值为-1</li>
<li>split（‘分隔符’）：将字符串转换为数组</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>稳固JS第五天</title>
    <url>/2021/06/14/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E4%BA%94%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="稳固JS第五天"><a href="#稳固JS第五天" class="headerlink" title="稳固JS第五天"></a>稳固JS第五天</h1><ol>
<li><h3 id="Javascript-简单类型与复杂类型"><a href="#Javascript-简单类型与复杂类型" class="headerlink" title="Javascript 简单类型与复杂类型"></a>Javascript 简单类型与复杂类型</h3><ol>
<li><p>简单类型与复杂类型</p>
<ul>
<li><p>简单类型又叫基本类型或者值类型，复杂类型又叫做引用类型</p>
<ul>
<li><p>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型</p>
<ul>
<li>但是null比较特殊，会返回一个空的Object对象</li>
<li>所以，如果有个变量我们以后打算存储为对象，暂时没想好放啥，这个时候就给null</li>
</ul>
</li>
<li><p>引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型，通过new关键字创建的对象，如Object，Array，Date等</p>
<span id="more"></span></li>
</ul>
</li>
</ul>
</li>
<li><p>堆和栈</p>
<ul>
<li>栈：由操作系统自动分配释放存储函数的参数值、局部变量等。其操作方式类似于数据结构中的栈（简单数据类型存放到栈里面）</li>
<li>堆：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收（复杂数据类型存放到堆里面）</li>
<li>（Tips：Javascript中没有堆栈的概念，只是通过堆栈的方式，可以让大家更容易的理解代码的一些执行方式，以便将来学习其他的语言）</li>
</ul>
</li>
<li><p>简单类型的内存分配</p>
<ul>
<li>是存放在栈里面，里面开辟的空间存放的是值</li>
</ul>
</li>
<li><p>复杂类型的内存分配</p>
<ul>
<li>首先在栈里面存放地址，这个地址指向堆里面的数据</li>
</ul>
</li>
<li><p>简单类型传参</p>
<ul>
<li>函数的形参可以看做是一个变量，当我们把一个值类型变量作为参数传递给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到外部的变量。</li>
</ul>
</li>
<li><p>复杂类型传参</p>
<ul>
<li>函数的形参可以看做是一个变量，当我那么把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参指向的是同一个堆地址，所以操作的是同一个对象</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h3><ol>
<li>Web APIs和JS基础关联性<ul>
<li>Web APIs阶段<ul>
<li>是W3C组织的标准</li>
<li>主要学习BOM和DOM</li>
<li>是js中独有的部分</li>
<li>主要学习页面交互</li>
<li>需要JS基础的内容做基础</li>
</ul>
</li>
</ul>
</li>
<li>API和Web API<ul>
<li>API：是一些预先定义的函数，目的是提供应用程序与前端开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</li>
<li>Web API：是浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM）</li>
</ul>
</li>
</ol>
</li>
<li><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ol>
<li><p>DOM简介</p>
<ul>
<li>什么是DOM？<ul>
<li>文档对象模型，处理HTML或XML的标准编程接口</li>
</ul>
</li>
<li>DOM树<ul>
<li>文档：一个页面就是一个文档，DOM中使用document表示</li>
<li>元素：页面内所有标签都是元素，DOM中使用element表示</li>
<li>节点：网页中所有的内容都是节点（标签，属性，文本，注释等），DOM中用node表示</li>
<li>DOM把以上内容都看做是对象</li>
</ul>
</li>
</ul>
</li>
<li><p>获取元素</p>
<ul>
<li>如何获取页面元素<ol>
<li>根据ID获取<ul>
<li>使用getElementById（）方法可以获取带有ID的元素对象</li>
<li>get获得Element元素，by通过id获得</li>
<li>参数id是大小写敏感的字符串</li>
<li>返回值是一个元素对象</li>
</ul>
</li>
<li>根据标签名获取<ul>
<li>使用getElementsByTagName()方法可以返回带有指定标签的<strong>对象合集</strong></li>
<li>返回的是，获取的元素对象的合集，以伪数组的形式存储的（不管页面中这个元素有没有或者是只有一个，返回的也是伪数组），所以我们想要操作里面的元素就需要遍历，且得到的元素对象是动态的</li>
<li>还可以获取某个元素内部所有指定标签名的子元素<ul>
<li>element.getElementsByTagName(‘标签名’)；</li>
<li>父元素必须是<strong>单个对象（必须指明是哪一个元素对象）</strong>，获取的时候不包括父元素自己</li>
</ul>
</li>
</ul>
</li>
<li>通过HTML5新增的方法获取<ul>
<li>IE9+兼容</li>
<li>使用document.getElementsByClassName(‘类名’)方法根据类名获取某些元素集合（伪数组）</li>
<li>使用document.querySelector(‘选择器’);方法根据选择器返回第一个元素对象，切记里面选择器需要加符号（类-&gt; . | id-&gt;#）</li>
<li>使用document.querySelectorAll(‘选择器’)方法根据指定选择器返回所有元素的集合（伪数组）</li>
</ul>
</li>
<li>特殊元素获取  <ol>
<li>获取body元素<ul>
<li>使用document.body</li>
</ul>
</li>
<li>获取html元素<ul>
<li>使用document.documentElement</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>事件基础</p>
<ul>
<li>事件概述<ul>
<li>javascript使我们有能力创建动态页面，而事件是可以被javascript侦测到的行为</li>
<li>网页中的每个元素都可以产生某些来触发Javascript的事件</li>
<li>事件由三部分组成：事件源、事件类型、事件处理程序，也称为事件三要素<ul>
<li>事件源：事件被触发的对象</li>
<li>事件类型：如何触发 什么事件</li>
<li>事件处理程序：通过一个函数赋值的方式完成</li>
</ul>
</li>
</ul>
</li>
<li>执行事件步骤<ol>
<li>获取事件源</li>
<li>注册事件（绑定事件）</li>
<li>添加事件处理程序（采用函数赋值的形式）</li>
</ol>
</li>
</ul>
</li>
<li><p>操作元素</p>
<ul>
<li><p>改变元素内容</p>
<ul>
<li>element.innerText:从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉（不识别HTML标签），非标准</li>
<li>element.innerHTML：起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行，W3C标准</li>
<li>这两个属性都是可读写的</li>
</ul>
</li>
<li><p>常用元素的属性操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：不同时间 不同图片和问候语</span></span><br><span class="line">    &lt;div&gt;该怎么问候你呢？&lt;/div&gt;</span><br><span class="line">    &lt;img src=&quot;image/01.jpg&quot;&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var img = document.getElementsByTagName(&#x27;img&#x27;);</span><br><span class="line">        var div = document.getElementsByTagName(&#x27;div&#x27;);</span><br><span class="line">        var time = prompt(&#x27;你想去几点呀？&#x27;)*1;</span><br><span class="line">        if(time&lt;6)&#123;</span><br><span class="line">            img[0].src = &quot;image/01.jpg&quot;;</span><br><span class="line">            div[0].innerHTML = &#x27;凌晨好呀！&#x27;;</span><br><span class="line">        &#125;else if(time&lt;12)&#123;</span><br><span class="line">            img[0].src = &quot;image/01.jpg&quot;;</span><br><span class="line">            div[0].innerHTML = &#x27;上午好呀！&#x27;;</span><br><span class="line">        &#125;else if(time&lt;18)&#123;</span><br><span class="line">            img[0].src = &quot;image/02.jpg&quot;;</span><br><span class="line">            div[0].innerHTML = &#x27;下午好呀！&#x27;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            img[0].src = &quot;image/03.jpg&quot;;</span><br><span class="line">            div[0].innerHTML = &#x27;晚上好呀！&#x27;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>表单元素的属性操作</p>
<ul>
<li><p>type、value、checked、selected、disabled</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：仿京东显示密码案例，点击按钮，将密码框切换成文本框</span></span><br><span class="line">          <span class="keyword">var</span> pas = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">          <span class="keyword">var</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">          btn1.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="keyword">if</span>(btn1.id===<span class="string">&#x27;btn1&#x27;</span>)&#123;</span><br><span class="line">              pas[<span class="number">0</span>].type= <span class="string">&#x27;text&#x27;</span>;</span><br><span class="line">              <span class="built_in">this</span>.id = <span class="string">&#x27;btn2&#x27;</span>;</span><br><span class="line">              <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;睁开了&#x27;</span></span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  pas[<span class="number">0</span>].type = <span class="string">&quot;password&quot;</span>;</span><br><span class="line">                  <span class="built_in">this</span>.id = <span class="string">&#x27;btn1&#x27;</span></span><br><span class="line">                  <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;闭上了&#x27;</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>样式属性操作</p>
<ul>
<li><p>element.style：行内样式操作</p>
</li>
<li><p>element.className：类名样式操作</p>
</li>
<li><p>Tips</p>
<ul>
<li><p>JS里面的样式采取驼峰命名法</p>
</li>
<li><p>JS修改style样式操作是行内样式，权重比较高</p>
</li>
<li><p>calssName 会直接更改元素的类名，会覆盖原先的类名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：点击关闭图片</span></span><br><span class="line">    &lt;img id=<span class="string">&quot;img1&quot;</span> src=<span class="string">&quot;image/01.jpg&quot;</span>&gt;</span><br><span class="line">    &lt;img id=&quot;img2&quot; src=&quot;image/02.jpg&quot;&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">          var img1 = document.getElementById(&#x27;img1&#x27;);</span><br><span class="line">          var img2 = document.getElementById(&#x27;img2&#x27;);</span><br><span class="line">          img1.onclick = function () &#123;</span><br><span class="line">              img1.style.display =&quot;none&quot;;</span><br><span class="line">              img2.style.display =&quot;none&quot;;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">//案例:当鼠标点击文本框时，里面的默认文字隐藏，当鼠标离开文本框时，里面的文字显示</span><br><span class="line">    &lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;手机&quot;&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">          var input = document.getElementById(&quot;input&quot;);</span><br><span class="line">          input.onmousemove = function()&#123;</span><br><span class="line">              input.focus();</span><br><span class="line">              input.placeholder = &#x27;&#x27;;</span><br><span class="line">          &#125;</span><br><span class="line">          input.onmouseleave= function()&#123;</span><br><span class="line">              input.blur();</span><br><span class="line">            input.placeholder = &#x27;手机&#x27;;</span><br><span class="line">          &#125;</span><br><span class="line">//案例：用户如果离开密码框，里面输入个数不是6~16，则提示错误信息</span><br><span class="line">    &lt;input id=&quot;input&quot; type=&quot;text&quot; style=&quot;display:inline-block;&quot;&gt;</span><br><span class="line">    &lt;p id=&quot;p&quot; style=&quot;display: inline-block;&quot;&gt;请输入正确信息&lt;/p&gt;</span><br><span class="line">      &lt;script&gt;</span><br><span class="line">          var input = document.getElementById(&quot;input&quot;);</span><br><span class="line">          var p = document.getElementById(&#x27;p&#x27;);</span><br><span class="line">          input.onblur= function()&#123;</span><br><span class="line">              if(input.value.length&lt;6)&#123;</span><br><span class="line">                  p.innerHTML = &quot;密码较短，最短支持6个字符&quot;;</span><br><span class="line">                  p.className = &quot;class1&quot;;</span><br><span class="line">              &#125;else if(input.value.length&gt;16)&#123;</span><br><span class="line">                p.innerHTML = &quot;密码较长，最长支持6个字符&quot;;</span><br><span class="line">                p.className = &quot;class1&quot;;</span><br><span class="line">              &#125;else&#123;</span><br><span class="line">                p.innerHTML = &quot;是合格密码&quot;;</span><br><span class="line">                p.className = &quot;class2&quot;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>排他思想</p>
<ul>
<li><p>首先先排除其他人，然后才设置自己的样式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：换肤</span></span><br><span class="line"><span class="comment">//自己的写法</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">        &lt;img src=&quot;image/01.jpg&quot; title=&quot;1&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;image/02.jpg&quot; title=&quot;2&quot;&gt;</span><br><span class="line">        &lt;img src=&quot;image/03.jpg&quot; title=&quot;3&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var img = document.getElementsByTagName(&#x27;img&#x27;);</span><br><span class="line">        var div = document.getElementsByTagName(&#x27;div&#x27;);</span><br><span class="line">        for(var i=0;i&lt;img.length;i++)&#123;</span><br><span class="line">            img[i].onclick = function()&#123;</span><br><span class="line">                div[0].className = &#x27;div&#x27;+this.title*1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">//总结：挺蠢的，没有想到去换src，记得for循环里用this</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>稳固JS第六天</title>
    <url>/2021/06/15/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E5%85%AD%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="稳固JS第六天"><a href="#稳固JS第六天" class="headerlink" title="稳固JS第六天"></a>稳固JS第六天</h1><ol>
<li><h3 id="DOM（续上）"><a href="#DOM（续上）" class="headerlink" title="DOM（续上）"></a>DOM（续上）</h3><span id="more"></span>

<ul>
<li><p>操作元素</p>
<ul>
<li><p>案例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：表单全选、反选（被注释的代码是自己写的，还是写得不够好）</span></span><br><span class="line">        <span class="keyword">var</span> j_cbAll = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;j_cbAll&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> j_tbs = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;j_tb&#x27;</span>).getElementsByTagName(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">        <span class="comment">// var num =0;</span></span><br><span class="line">        j_cbAll.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//     if(this.checked)&#123;</span></span><br><span class="line">        <span class="comment">//     for(var i=0;i&lt;j_tbs.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//         j_tbs[i].checked = &#x27;checked&#x27;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     for(var i=0;i&lt;j_tbs.length;i++)&#123;</span></span><br><span class="line">        <span class="comment">//         j_tbs[i].checked = &#x27;&#x27;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;j_tbs.length;i++)&#123;</span><br><span class="line">            j_tbs[i].checked = <span class="built_in">this</span>.checked;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;j_tbs.length;j++)&#123;</span><br><span class="line">            j_tbs[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// if(this.checked)&#123;</span></span><br><span class="line">                <span class="comment">//     num++;</span></span><br><span class="line">                <span class="comment">// &#125;else&#123;</span></span><br><span class="line">                <span class="comment">//     num--;</span></span><br><span class="line">                <span class="comment">//     j_cbAll.checked = &#x27;&#x27;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// if(num ==4)&#123;</span></span><br><span class="line">                <span class="comment">//     j_cbAll.checked = &#x27;checked&#x27;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;j_tbs.length;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!j_tbs[i].checked)&#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">//退出for循环，提高执行效率</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j_cbAll.checked = flag;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义属性的操作</p>
<ul>
<li><p>获取属性值：</p>
<ul>
<li>element.属性；常用来获取内置属性（元素本身自带的属性）</li>
<li>element.getAttribute(‘属性’);  常用来获取自定义属性</li>
</ul>
</li>
<li><p>设置属性值</p>
<ul>
<li>element.属性=”值”；设置内置属性</li>
<li>element.setAttribute(‘属性’,’值’)；主要针对于自定义属性</li>
</ul>
</li>
<li><p>移除属性值</p>
<ul>
<li>element.removeAttribute(‘属性’)；</li>
</ul>
</li>
<li><p>案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tab栏切换(给上面的设定index就行)</span></span><br><span class="line">        <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btns&#x27;</span>).getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> btn2s = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn2s&#x27;</span>).getElementsByTagName(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;btns.length;i++)&#123;</span><br><span class="line">            btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;btns.length;j++)&#123;</span><br><span class="line">                    btns[j].className=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                    btns[j].setAttribute(<span class="string">&#x27;index&#x27;</span>,j);</span><br><span class="line">                    btn2s[j].style = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.className = <span class="string">&#x27;current&#x27;</span>;</span><br><span class="line">               btn2s[<span class="built_in">this</span>.getAttribute(<span class="string">&#x27;index&#x27;</span>)].style = <span class="string">&#x27;display:block&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>H5自定义属性</p>
<ul>
<li>自定义属性的目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</li>
<li>但有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性</li>
<li>所以H5规定自定义属性data-做为属性名并且赋值</li>
<li>获取H5自定义属性(假设自定义属性为date-index)<ul>
<li>兼容性获取 element.getAttribule(‘date-index’)；</li>
<li>H5新增element.dataset.index 或者element.dateset[‘index’],IE11才开始支持，（只能获取date-开头的自定义属性）</li>
<li>dataset是个集合，里面存放了所有以data开头的自定义属性（对象）</li>
<li>如果自定义属性中有多个-链接的单词，我们获取的时候采取驼峰命名法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>节点操作</p>
<ol>
<li><p>为什么要学节点操作</p>
<ul>
<li>获取元素通常使用两种方式<ul>
<li>利用DOM提供的方法获取元素（逻辑性不强，繁琐）</li>
<li>利用节点的层次关系获得元素（逻辑性强，兼容性较差）</li>
</ul>
</li>
</ul>
</li>
<li><p>节点概述</p>
<ul>
<li>网页中的所有内容都是节点，在DOM中用node表示</li>
<li>一般，节点至少拥有nodeType（节点类型），nodeName（节点名称）、nodeValue（节点值），这三个基本属性<ul>
<li>元素节点 nodeType为1</li>
<li>属性节点 nodeType为2</li>
<li>文本节点 nodeType为3</li>
</ul>
</li>
<li>在实际开发中，节点操作主要操作的是元素节点</li>
</ul>
</li>
<li><p>节点层级</p>
<ul>
<li><p>利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄弟层级关系</p>
<ul>
<li><p>父级节点</p>
<ul>
<li>node.parentNode：得到的是离node节点最近的父级节点，找不到返回为null</li>
</ul>
</li>
<li><p>子级节点</p>
<ul>
<li><p>parentNode.childNodes(标准)：返回包含指定节点的子节点的集合，该集合为即使更新的集合，如果只想要获得里面的元素节点，则需要专门处理。所以一般不提倡使用childNodes</p>
</li>
<li><p>parentNode.children(非标准)：是一个只读属性，返回所有的子元素节点，它只会返回元素节点，其余节点不返回。</p>
</li>
<li><p>parentNode.firstChild / lastChild：返回的是一个第一个/最后一个 子节点，不管是文本节点还是元素节点</p>
</li>
<li><p>parentNode.firstElementChild / lastElementChild：返回第一个/最后一个元素节点，但是这个有兼容问题，IE9+才支持</p>
</li>
<li><p>实际开发写法，既没有兼容问题，又返回元素节点</p>
<ul>
<li>parentNode.children[0] | parentNode.children[parent.children.length-1]</li>
</ul>
</li>
<li><p>案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下拉菜单</span></span><br><span class="line">        <span class="keyword">var</span> li = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;123&#x27;</span>).children;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;li.length;i++)&#123;</span><br><span class="line">            li[i].onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.children[<span class="number">1</span>].style.display = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            li[i].onmouseout= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.children[<span class="number">1</span>].style.display = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>兄弟节点</p>
<ul>
<li>node.nextSibling / previousSibling:下 / 上一个兄弟节点，包含文本节点</li>
<li>node.nextElementSibling / previousElemenetSibling:下 / 上一个兄弟节点，只包含元素节点，IE9+支持 </li>
</ul>
</li>
<li><p>创建节点</p>
<ul>
<li>document.createElement(‘tagName’)：方法创建由tagName指定的HTML元素。因为这些元素原先不存在，是根据我们需求动态生成的，所以我们也成为动态创建元素节点</li>
</ul>
</li>
<li><p>添加节点</p>
<ul>
<li><p>node.appendChild(child)：将一个节点添加到指定父节点列表末尾，类似于CSS里面after伪元素</p>
</li>
<li><p>node.insertBefore(child,指定元素)：将一个节点添加到父节点的指定子节点前面。类似于CSS里面的before伪元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：简易留言板</span></span><br><span class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(text.value ==<span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">                alert(<span class="string">&#x27;您输入内容为空&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">                li.innerHTML =text.value;</span><br><span class="line">                ul.appendChild(li);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>删除节点</p>
<ul>
<li><p>node.removeChild(child)：从DOM中删除一个子节点，返回删除的节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除节点案例（有两个删除按钮）</span></span><br><span class="line">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(text.value ==<span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">                alert(<span class="string">&#x27;您输入内容为空&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">                li.innerHTML =text.value+<span class="string">&quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;</span>;</span><br><span class="line">                ul.appendChild(li);</span><br><span class="line">                btn1.disabled = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">var</span> <span class="keyword">as</span> = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">as</span>.length;i++)&#123;</span><br><span class="line">                    <span class="keyword">as</span>[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">                        ul.removeChild(<span class="built_in">this</span>.parentNode)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        btn1.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ul.children.length ==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.disabled = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ul.removeChild(ul.children[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>复制节点（克隆节点）</p>
<ul>
<li>node.cloneNode( )：返回调用该方法的节点的一个副本</li>
<li>如果括号内参数为空或者为false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。为true，则深拷贝，复制节点本身，还有里面所有的子节点</li>
</ul>
</li>
<li><p>动态表格生成实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> datas = [&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;瑶姐&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">100</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;嘎子&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">98</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;杰华&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">99</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小胡&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">88</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;贱贱&#x27;</span>,</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;JavaScript&#x27;</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">0</span></span><br><span class="line">&#125;];</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 开始建立动态表格</span></span><br><span class="line"><span class="keyword">var</span> tbody =<span class="built_in">document</span>.querySelector(<span class="string">&#x27;tbody&#x27;</span>);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;datas.length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 创建行</span></span><br><span class="line">    <span class="keyword">var</span> tr=<span class="built_in">document</span>.createElement(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">    tbody.appendChild(tr);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 创建格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> datas[i])&#123;</span><br><span class="line">        <span class="keyword">var</span> td = <span class="built_in">document</span>.createElement(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">        tr.appendChild(td);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 将数据动态写入格子</span></span><br><span class="line">        td.innerHTML = datas[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 创建删除节点</span></span><br><span class="line">    <span class="keyword">var</span> td = <span class="built_in">document</span>.createElement(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">    tr.appendChild(td);</span><br><span class="line">    td.innerHTML = <span class="string">&#x27;&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="comment">//删除功能实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">as</span> = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">as</span>.length;i++)&#123;</span><br><span class="line">        <span class="keyword">as</span>[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            tbody.removeChild(<span class="built_in">this</span>.parentNode.parentNode)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>三种动态创建元素区别</p>
<ul>
<li>document.write():是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致文档流全部重绘</li>
<li>element.innerHTML:创建多个元素效率会更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</li>
<li>document.createElement():创建多个元素效率稍低，但是结构清晰</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>稳固JS第七天</title>
    <url>/2021/06/16/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E4%B8%83%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="稳固JS第七天"><a href="#稳固JS第七天" class="headerlink" title="稳固JS第七天"></a>稳固JS第七天</h1><ul>
<li><h3 id="DOM（续续上）"><a href="#DOM（续续上）" class="headerlink" title="DOM（续续上）"></a>DOM（续续上）</h3><ul>
<li><p>DOM重点核心</p>
<span id="more"></span>

<ul>
<li>创建<ul>
<li>document.write</li>
<li>innerHTML</li>
<li>createElement</li>
</ul>
</li>
<li>增<ul>
<li>appendChild</li>
<li>insertBefore</li>
</ul>
</li>
<li>删<ul>
<li>removeChild</li>
</ul>
</li>
<li>改<ul>
<li>修改元素属性：src、href、title等</li>
<li>修改普通元素内容：innnerHTML、innerText</li>
<li>修改表单元素：value、type、disabled等</li>
<li>修改元素样式：style、className</li>
</ul>
</li>
<li>查<ul>
<li>DOM提供的API方法：getElementById等古老用法，不太推荐</li>
<li>H5提供的新方法：querySelector、querySelectorAll</li>
<li>利用节点操作获取元素：父（parentNode）、子（children）、兄（previousElementSibing、nextElementSibling）提倡</li>
</ul>
</li>
<li>属性操作（主要针对自定义属性）<ul>
<li>setAttribute：设置dom的属性值</li>
<li>getAttribute：得到dom的属性值</li>
<li>removeAttribute：移除属性</li>
</ul>
</li>
<li>事件操作<ul>
<li>onclick、onmouseover（经过）、onmouseout（离开）、onfoucs（获取焦点）、onblur（失去焦点）、onmousemove（鼠标移动）、onmouseup（鼠标弹起）、onmousedown（鼠标按下）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h3><ol>
<li><p>注册事件（绑定事件）</p>
<ul>
<li>给元素添加事件就称为注册事件或绑定事件</li>
<li>注册事件有两种方式：传统方式和方法监听注册方式<ul>
<li>传统注册方式：注册事件的唯一性（同一个元素同一个事件，只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数）</li>
<li>方法监听注册事件：addEventListener()它是一个方法<ul>
<li>IE9之前不支持此方法，可使用attachEvent（）代替</li>
<li>同一个元素、同一个事件 可以注册多个监听器</li>
<li>按照注册顺序依次执行</li>
<li>eventTarget.addEventListener(type,listener[,useCapture])<ul>
<li>type：<strong>事件类型字符串</strong>，比如click、mouseover，<strong>注意不要带on</strong></li>
<li>listener：事件处理函数，事件发生时，会调用该监听函数</li>
<li>useCapture：可选参数，是一个布尔值，默认是false,[ ]包裹的是可选</li>
</ul>
</li>
</ul>
</li>
<li>attachEvent（）：非标准，但兼容，IE独有，但是要IE9以前的版本<ul>
<li>evnetTarget.attachEvent(eventNameWithOn,callback)</li>
<li>eventNameWithOn：事件类型字符串，这个要加on</li>
<li>callback：事件处理函数，当目标触发事件时回调函数被调用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>删除事件（解绑事件）</p>
<ul>
<li><p>传统方式删除事件：设置为null</p>
</li>
<li><p>方法监听方式</p>
<ul>
<li><p>eventTarget.removeEventListener(type,listener,[useCapture]);</p>
</li>
<li><p>detachEvent：操作方法和上面的一样，IE9以下兼容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法监听方式删除事件</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,fn);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;我只执行一次&#x27;</span>);</span><br><span class="line">    btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为删除事件需要拿到函数名，所以不能像之前那样使用匿名函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DOM事件流</p>
<ul>
<li><p>事件流描述的是从页面中接收事件的顺序。事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流</p>
</li>
<li><p>事件流代码验证</p>
<ul>
<li><p>JS代码中只能执行捕获或者冒泡其中一个阶段</p>
</li>
<li><p>onclick和attachEvent只能的到冒泡阶段</p>
</li>
<li><p>eventTarget.addEventListener(type,listener[,useCapture])，第三个参数为true，表示在事件捕获阶段调用事件处理程序；如果是false（不写就默认false），表示在事件冒泡阶段调用事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码验证</span></span><br><span class="line">        <span class="keyword">var</span> son = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.son&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> far = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.father&#x27;</span>);</span><br><span class="line">        son.addEventListener(<span class="string">&#x27;click&#x27;</span>,fn1);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;我是儿子&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        far.addEventListener(<span class="string">&#x27;click&#x27;</span>,fn2);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;我是爸爸&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.都为false或默认，处于冒泡，点击儿子div，先弹出儿子，再弹父亲</span></span><br><span class="line"><span class="comment">2.都为true，处于捕获阶段，点击儿子div，先弹出父亲，再弹儿子</span></span><br><span class="line"><span class="comment">3.实际开发中我们很少使用事件捕获，我们更关注事件冒泡</span></span><br><span class="line"><span class="comment">4.有的事件没有冒泡：如onblur,onfocus,onmouseenter,onmouseleave</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>事件对象</p>
<ul>
<li><p>event就是一个事件对象，写到我们侦听函数的小括号里面，当形参来看</p>
</li>
<li><p>事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要传递参数</p>
</li>
<li><p>事件对象 是 我们事件一系列相关数据的集合</p>
</li>
<li><p>这个事件对象我们可以自己命名 比如 event、e、evt</p>
</li>
<li><p>事件对象也有兼容性问题，IE678通过window.event</p>
</li>
<li><p>兼容性处理方法：e = e || window.event</p>
</li>
<li><p>事件对象常见的属性和方法</p>
<ul>
<li><p>e.target：返回触发事件对象 （标准），this返回的是绑定事件的对象</p>
</li>
<li><p>e.srcElemnet：返回触发事件对象 （非标准，IE6-8使用）</p>
</li>
<li><p>e.type：返回事件的类型，不带on</p>
</li>
<li><p>e.preventDefault()：该<strong>方法</strong> 阻止默认事件 （标准）</p>
</li>
<li><p>e.returnValue：该<strong>属性</strong> 阻止默认事件（非标准，IE6-8使用，比如不让连接跳转）</p>
</li>
<li><p>（Tips：return false也能阻止默认行为，而且没有兼容问题，但是return后面的代码不能执行，且只能用于传统注册方式）</p>
</li>
<li><p>e.stopPropagation()：阻止冒泡 （标准）</p>
</li>
<li><p>e.cancelBubble：该属性阻止冒泡（非标准，IE6-8使用）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事件委托（代理、委派）</p>
<ul>
<li><p>也称事件代理，在JQ里面称为事件委派</p>
</li>
<li><p>事件委托的原理：</p>
<ul>
<li><p>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理的影响设置每个子节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码实现     </span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">        ul.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            e.target.style.backgroundColor= <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>常用的鼠标事件</p>
<ul>
<li><p>禁止鼠标右键菜单</p>
<ul>
<li>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</li>
</ul>
</li>
<li><p>禁止鼠标选中（selectstart 开始选中）</p>
</li>
<li><p>鼠标事件对象：</p>
<ul>
<li><p>e.clientX：返回鼠标相对于浏览器窗口可视化区的X坐标</p>
</li>
<li><p>e.clientY：返回鼠标相对于浏览器窗口可视化区的Y坐标</p>
</li>
<li><p>e.pageX：返回鼠标相对于文档页面的X坐标，IE9+支持</p>
</li>
<li><p>e.pageY：返回鼠标相对于文档页面的Y坐标，IE9+支持</p>
</li>
<li><p>e.screenX：返回鼠标相对于电脑屏幕的X坐标</p>
</li>
<li><p>e.screenY：返回鼠标相对于电脑屏幕的Y坐标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：图片跟随鼠标移动</span></span><br><span class="line">        <span class="keyword">var</span> gif = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> x = e.pageX;</span><br><span class="line">            <span class="keyword">var</span> y = e.pageY;</span><br><span class="line">            gif.style.left = x-<span class="number">45</span>+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">            gif.style.top = y-<span class="number">45</span>+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>常用的键盘事件</p>
<ul>
<li><p>onkeyup：某个键盘按键被松开时触发</p>
</li>
<li><p>onkeydown：某个键盘按钮被按下时触发</p>
</li>
<li><p>onkeypress：某个键盘按钮被按下时触发，但是它不能识别功能键，如：ctrl、shift等</p>
<ul>
<li>三个事件的执行顺序：keydown-keypress-keyup</li>
</ul>
</li>
<li><p>keyCode属性可以获得相应的ASCLL码的值</p>
<ul>
<li><p>我们的keyup和keydown事件不区分大小写 ，a与A得到的都是65</p>
</li>
<li><p>keypress可以区分字母大小写，a为97，A为65</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：按下s，自动获取焦点</span></span><br><span class="line">    <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(e.keyCode==<span class="number">83</span>)&#123;</span><br><span class="line">            input.focus();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//案例：模拟京东快递单号查询</span></span><br><span class="line">      <span class="keyword">var</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        div.style.display = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">        div.innerHTML = input.value;</span><br><span class="line">        <span class="keyword">if</span>(input.value === <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">            div.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//这里使用keydown和press，触发函数会比input的value先触发，所以会慢一步</span></span><br><span class="line">    input.addEventListener(<span class="string">&#x27;blur&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        div.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(input.value!=<span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">        input.addEventListener(<span class="string">&#x27;focus&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            div.style.display = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>剩下时间去找计算机网络工程的2000字小论文啦~明天要去看房子签合同，不知道明天能学多久呀，(〃＞皿＜)</p>
<p><img src="file:///C:\Users\force\AppData\Local\Temp\SGPicFaceTpBq\9140\01CF67D6.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title>稳固JS第八天</title>
    <url>/2021/06/17/%E7%A8%B3%E5%9B%BAJS%E7%AC%AC%E5%85%AB%E5%A4%A9/</url>
    <content><![CDATA[<h1 id="稳固JS第八天"><a href="#稳固JS第八天" class="headerlink" title="稳固JS第八天"></a>稳固JS第八天</h1><ol>
<li><h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><ol>
<li><p>BOM概述</p>
<ul>
<li>浏览器对象模型（把浏览器当对象来看），它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window</li>
<li>BOM缺乏标准（浏览器厂商在各自浏览器上定义的），会有很多兼容问题</li>
<li>BOM比DOM更大，它包含DOM</li>
<li>Window对象是浏览器的顶级对象，它具有双重角色<ol>
<li>它是JS访问浏览器窗口的一个接口</li>
<li>它是全局对象，定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li>
<li>Window下的一个特殊属性window.name</li>
</ol>
</li>
</ul>
</li>
<li><p>window对象的常见事件</p>
<ul>
<li><strong>window.onload = function() { }</strong> 或者 <strong>window.addEventListener(‘load’,function() { }</strong> );，当文档内容完全加载完成后会触发该事件，就调用处理函数<ul>
<li>前面这个传统的方式，只能写一次，以最后的那个为准；后面监听器的新方式，就不会有这个问题</li>
</ul>
</li>
<li>**document.addEventListener(‘DOMContenetLoaded’,function() { } );**，事件触发时，仅当DOM加载完成，不包括样式表、图片、falsh等，IE9+才支持<ul>
<li>如果页面图片很多的话，从用户访问到onload触发可能需要比较长的时间，交互效果就不能实现，必然影响用户的体验，此时用DOMContentLoaded事件比较合适</li>
</ul>
</li>
<li>调整窗口大小事件<ul>
<li><strong>window.onresize</strong> 是调整窗口大小加载事件，当触发时就调用处理函数</li>
<li>只要窗口大小发生像素变化，就会触发这个事件</li>
<li>我们经常利用这个事件完成响应式布局。window.innerWidth 当前屏幕宽度</li>
</ul>
</li>
</ul>
</li>
<li><p>定时器</p>
<ul>
<li><p>window对象给我们提供了两个定时器</p>
<ol>
<li><p><strong>setTimeout（）</strong>：</p>
<ul>
<li>window.setTimeout(调用函数,[,延迟的毫秒数])；延迟时间省略默认为0</li>
<li>方法用于设置一个定时器，该定时器在定时器到期后执行调用函数</li>
<li>调用函数可以直接写函数，还可以写函数名，还可以  ‘函数名（）’</li>
<li>页面中可能有很多的定时器，应该给定时器加上标识符</li>
<li>停止setTime（）定时器<ol>
<li>*window.clearTimeout(timeout ID)*方法，取消了先前通过调用的setTimeout建立的定时器</li>
<li>window可以省略</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>setInterval（）</strong>：</p>
<ul>
<li><p>window.setInterval(回调函数,[,间隔的毫秒数])；延迟时间省略默认为0</p>
</li>
<li><p>很多地方和setTimeout相似</p>
</li>
<li><p>方法重复调用一个函数，每隔这个时间，就去调用一次回调函数</p>
</li>
<li><p>案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//倒计时</span></span><br><span class="line">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> hour = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.hour&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> minute = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.minute&#x27;</span>);</span><br><span class="line">            <span class="keyword">var</span> second = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.second&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> year = prompt(<span class="string">&quot;截止时间，年&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> mouth = prompt(<span class="string">&quot;截止时间，月&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> day = prompt(<span class="string">&quot;截止时间,日&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> hours = prompt(<span class="string">&quot;截止时间，时&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> min = prompt(<span class="string">&quot;截止时间，分&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> miao = prompt(<span class="string">&quot;截止时间,秒&quot;</span>)*<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">var</span> time1 = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> nowTime = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">var</span> inputTime = +<span class="keyword">new</span> <span class="built_in">Date</span>(year+<span class="string">&#x27;-&#x27;</span>+mouth+<span class="string">&#x27;-&#x27;</span>+day+<span class="string">&#x27; &#x27;</span>+hours+<span class="string">&#x27;:&#x27;</span>+min+<span class="string">&#x27;:&#x27;</span>+miao);</span><br><span class="line">            <span class="keyword">var</span> timer = (inputTime - nowTime)/<span class="number">1000</span>;<span class="comment">//化为秒</span></span><br><span class="line">            <span class="comment">// var d = parseInt(timer/60/60/24);</span></span><br><span class="line">            <span class="comment">// d = d&lt;10?&#x27;0&#x27; + d : d;</span></span><br><span class="line">            <span class="keyword">var</span> h = <span class="built_in">parseInt</span>(timer/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>);</span><br><span class="line">            h = h&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + h : h;</span><br><span class="line">            hour.innerHTML = h;</span><br><span class="line">            <span class="keyword">var</span> m = <span class="built_in">parseInt</span>(timer/<span class="number">60</span>%<span class="number">60</span>);</span><br><span class="line">            m = m&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + m : m;</span><br><span class="line">            minute.innerHTML = m;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="built_in">parseInt</span>(timer%<span class="number">60</span>);</span><br><span class="line">            s = s&lt;<span class="number">10</span>?<span class="string">&#x27;0&#x27;</span> + s : s;</span><br><span class="line">            second.innerHTML = s;</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li><p>回调函数</p>
<ul>
<li>简单理解就是：上一件事干完，再回头调用这个函数</li>
</ul>
</li>
<li><p>停止setInterval（）定时器</p>
<ul>
<li><p>window.clearInterval(intervalID);方法取消先前通过调用setInterval建立的定时器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：发送短信</span></span><br><span class="line">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">            button.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> time1 = <span class="number">4</span>;</span><br><span class="line">                button.disabled = <span class="literal">true</span>;</span><br><span class="line">                button.innerHTML = <span class="string">&quot;再过5秒后可以发送&quot;</span><span class="comment">//这里先改变，可以提高用户体验</span></span><br><span class="line">                <span class="keyword">var</span> time = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                    button.innerHTML = <span class="string">&#x27;再过&#x27;</span>+time1+<span class="string">&quot;秒后可以发送&quot;</span></span><br><span class="line">                    <span class="keyword">if</span>(time1 &lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">clearInterval</span>(time);</span><br><span class="line">                        button.innerHTML = <span class="string">&#x27;发送&#x27;</span>;</span><br><span class="line">                        button.disabled = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    time1--;</span><br><span class="line">                &#125;,<span class="number">1000</span>)    </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>this指向问题</p>
<ol>
<li>全局作用域或普通函数中this指向全局对象window（注意定时器里面的this，指向window）</li>
<li>方法调用中，谁调用this就指向谁</li>
<li>构造函数中this指向构造函数的实例</li>
</ol>
</li>
</ul>
</li>
<li><p>JS执行机制</p>
<ul>
<li>JS语言一大特点就是单线程，也就是说，同一时间只能做一件事情</li>
<li>为了解决这个问题，利用多核CPU的计算能力，于是，JS中出现了同步和异步<ul>
<li>同步任务：在主线程上执行，形成一个执行栈</li>
<li>异步任务：JS的异步是通过回调函数实现的<ul>
<li>一般而言异步任务有三种类型</li>
<li>普通事件，如click、resize等</li>
<li>资源加载：load、error等</li>
<li>定时器：setInterval、setTimeout</li>
</ul>
</li>
<li>异步任务相关回调函数添加到任务队列（消息队列）中</li>
</ul>
</li>
<li>JS执行机制<ol>
<li>先执行 执行栈中的同步任务</li>
<li>异步任务放入任务队列中</li>
<li>一旦执行栈中所有的同步任务执行完毕，系统就会按次序读取任务列表中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</li>
</ol>
</li>
<li>由于主线程不断地重复获得任务、执行任务、再获取任务、再执行、所以这种机制被称为事件循环</li>
</ul>
</li>
<li><p>location对象</p>
<ul>
<li><p>window对象给我们提供了一个location属性用于获取或设置窗体的URL，并且可以用于解析URL，因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象</p>
</li>
<li><p>location对象的属性：</p>
<ul>
<li>loaction.href：获取或设置 整个URL</li>
<li>location.host：返回主机（域名）</li>
<li>location.port：返回端口号</li>
<li>location.pathname：返回路径</li>
<li>location.search：返回参数</li>
<li>loaction.hash：返回片段 #后面内容 常见于连接 锚点</li>
</ul>
</li>
<li><p>案例：获取URL参数数据</p>
</li>
<li><pre><code class="js">    window.onload = function ()&#123;
        var uname1 = location.search;
        console.log(uname1);
        var uname2 = uname1.substr(1);
        console.log(uname2);
        var uname3 = uname2.split(&#39;=&#39;);
        console.log(uname3);
        var div = document.querySelector(&#39;div&#39;);
        div.innerHTML = uname3[1]+&#39;欢迎你&#39;
    &#125;
</code></pre>
</li>
<li><p>location对象的方法</p>
<ul>
<li>loaction.assign()：跟href一样，可以跳转页面（也成为重定向页面），记录历史，可以后退页面</li>
<li>location.replace()：替换当前页面，因为不记录历史，不可以回退</li>
<li>location.reload()：重新加载页面，相当于刷新按钮，如果参数为true，则为ctrl+F5强制刷新</li>
</ul>
</li>
</ul>
</li>
<li><p>navigation对象</p>
<ul>
<li>包含了有关浏览器的信息，里面有很多属性，我们最常用的是useAgent，该属性可以返回由客户机发送服务器的user-agent头部的值</li>
</ul>
</li>
<li><p>history对象</p>
<ul>
<li>window对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL</li>
<li>对象方法：<ul>
<li>back（）：后退功能</li>
<li>forward（）：前进功能</li>
<li>go（参数）：前进后退功能，参数n为前进n个，-n为后退n个页面</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
  </entry>
</search>
